<map version="1.0.1"><node CREATED="1593745252658" ID="ID_root" MODIFIED="1593745252658" TEXT="Java"><node CREATED="1593745252658" ID="ID_67a06d4be478" POSITION="right" MODIFIED="1593745252658" TEXT="大数据"><node CREATED="1593745252658" ID="ID_11dc8058ebe8" MODIFIED="1593745252658" TEXT="HDFS"><node CREATED="1593745252658" ID="ID_4dc9bfa194ae" MODIFIED="1593745252658" TEXT="HDFS的思想"><node CREATED="1593745252658" ID="ID_f86262bb73d4" MODIFIED="1593745252658" TEXT="hdfs是通过分布式集群来存储文件，同时为客户端提供便捷的访问方式，一个虚拟的访问目录结构"></node><node CREATED="1593745252658" ID="ID_306ebb63ef94" MODIFIED="1593745252658" TEXT="文件存储到hdfs集群中去的时候是被切分成block的"></node><node CREATED="1593745252658" ID="ID_4d7a2fec166b" MODIFIED="1593745252658" TEXT="文件的block存放在若干台datanode节点上"></node><node CREATED="1593745252658" ID="ID_d1d2918f90ab" MODIFIED="1593745252658" TEXT="HDFS文件系统的文件与真实的block之间有映射关系，由namenode管理"></node><node CREATED="1593745252658" ID="ID_c86dca64158f" MODIFIED="1593745252658" TEXT="每一个block在集群中会存储多个副本，好处是可以提高数据的可靠性，还可以提高访问的吞吐量"></node></node><node CREATED="1593745252658" ID="ID_0fdbf552dc28" MODIFIED="1593745252658" TEXT="构成"><node CREATED="1593745252658" ID="ID_17667eb55732" MODIFIED="1593745252658" TEXT="NameNode"><node CREATED="1593745252658" ID="ID_da98f807dc9a" MODIFIED="1593745252658" TEXT="职责"><node CREATED="1593745252658" ID="ID_1cac7bf2cc8e" MODIFIED="1593745252658" TEXT="维护元数据信息"></node><node CREATED="1593745252658" ID="ID_d5a75941bf21" MODIFIED="1593745252658" TEXT="维护hdfs的目录树(虚拟目录)"></node><node CREATED="1593745252658" ID="ID_33701d269687" MODIFIED="1593745252658" TEXT="响应客户端的请求"></node></node></node><node CREATED="1593745252658" ID="ID_15328e702a5b" MODIFIED="1593745252658" TEXT="DataNode"></node><node CREATED="1593745252658" ID="ID_139b897e7435" MODIFIED="1593745252658" TEXT="Secondary NameNode"></node></node><node CREATED="1593745252658" ID="ID_e43a98b30d31" MODIFIED="1593745252658" TEXT="上传文件过程"><node CREATED="1593745252658" ID="ID_b6d787549540" MODIFIED="1593745252658" TEXT="1 客户端上传文件时，NN首先往edits log文件中记录元数据操作日志"></node><node CREATED="1593745252658" ID="ID_52ff022ac2c5" MODIFIED="1593745252658" TEXT="2 客户端开始上传文件，完成后返回成功信息给NN，NN就在内存中写入这次上传操作的新产生的元数据信息"></node><node CREATED="1593745252658" ID="ID_0363265aaabc" MODIFIED="1593745252658" TEXT="3 每当editslog写满时，需要将这一段时间的新的元数据刷到fsimage文件中去"><node CREATED="1593745252658" ID="ID_9c1864b26078" MODIFIED="1593745252658" TEXT="1 NN通知SN进行checkpoint操作"></node><node CREATED="1593745252658" ID="ID_75616eacf3c6" MODIFIED="1593745252658" TEXT="2 停止editslog文件写操作，接下来的操作写在edits.new文件中"></node><node CREATED="1593745252658" ID="ID_6152eea27db1" MODIFIED="1593745252658" TEXT="3 SN将NN中的fsimage和editslog下载"></node><node CREATED="1593745252658" ID="ID_95789d3032b9" MODIFIED="1593745252658" TEXT="4 进行合并成 fsimage.chkpoint"></node><node CREATED="1593745252658" ID="ID_871db688e910" MODIFIED="1593745252658" TEXT="5 上传给NN，NN将fsimage.chkpoint和edits.new改名"></node></node></node><node CREATED="1593745252658" ID="ID_589afb19b9d6" MODIFIED="1593745252658" TEXT="Hadoop的RPC实现"><node CREATED="1593745252658" ID="ID_bdfc67e8e3e2" MODIFIED="1593745252658" TEXT="1 生成调用端socket程序动态代理对象，代理对象要实现抽象方法"></node><node CREATED="1593745252658" ID="ID_e6f7440a7b50" MODIFIED="1593745252658" TEXT="2 通过proxy调用业务方法"></node><node CREATED="1593745252658" ID="ID_bd785a592f75" MODIFIED="1593745252658" TEXT="3 调用socket的抽象方法"></node><node CREATED="1593745252658" ID="ID_66d441ab53f2" MODIFIED="1593745252658" TEXT="4 发送调用请求"></node><node CREATED="1593745252658" ID="ID_be69c7aa7adb" MODIFIED="1593745252658" TEXT="5 生成实现接口的动态代理对象"></node><node CREATED="1593745252658" ID="ID_6d0b38a5acb5" MODIFIED="1593745252658" TEXT="6 调用业务代理对象的具体业务方法"></node><node CREATED="1593745252658" ID="ID_d85fd228a580" MODIFIED="1593745252658" TEXT="7 获取调用结果"></node><node CREATED="1593745252658" ID="ID_0f64d102ea37" MODIFIED="1593745252658" TEXT="8 返回调用结果"></node></node></node><node CREATED="1593745252658" ID="ID_49efc579c3f5" MODIFIED="1593745252658" TEXT="Yarn（资源调度）"><node CREATED="1593745252658" ID="ID_48242c03d546" MODIFIED="1593745252658" TEXT="yarn执行流程"><node CREATED="1593745252658" ID="ID_4a33acaa2ab5" MODIFIED="1593745252658" TEXT="1 执行jar包，jar包(代码：job.waitForCompletion())执行RunJar进程，进程向 resourcemanager申请一个job"></node><node CREATED="1593745252658" ID="ID_ca7369a9d717" MODIFIED="1593745252658" TEXT="2 resourcemanager返回job相关资源提交的路径(staging-dir)和为本job产生的jobID"></node><node CREATED="1593745252658" ID="ID_e41fa88ce24a" MODIFIED="1593745252658" TEXT="3 Runjar 提交资源到对应的staging-dir中"></node><node CREATED="1593745252658" ID="ID_b4e5f628c5bc" MODIFIED="1593745252658" TEXT="4 Runjar向resourcemanager汇报提交结果"></node><node CREATED="1593745252658" ID="ID_1d713f38c543" MODIFIED="1593745252658" TEXT="5 resourcemanager将本job加入任务队列"></node><node CREATED="1593745252658" ID="ID_6e4b333d79bc" MODIFIED="1593745252658" TEXT="6 node manager 向resourcemanager领取任务"></node><node CREATED="1593745252658" ID="ID_0c50843e5d1e" MODIFIED="1593745252658" TEXT="7 nodemanager分配运行资源容器"></node><node CREATED="1593745252658" ID="ID_605c6784f896" MODIFIED="1593745252658" TEXT="8 resourcemanager选取一台nodemanager启动mrappmaster"></node><node CREATED="1593745252658" ID="ID_dd127380590d" MODIFIED="1593745252658" TEXT="9 mrappmaster操作其他nodemanager启动yarn-child，执行map task和reduce task"></node></node></node></node><node CREATED="1593745252658" ID="ID_6dcb3dd4b57d" POSITION="right" MODIFIED="1593745252658" TEXT="框架"><node CREATED="1593745252658" ID="ID_7907358ca706" MODIFIED="1593745252658" TEXT="Spring"><node CREATED="1593745252658" ID="ID_eda14d896ad2" MODIFIED="1593745252658" TEXT="aop"><node CREATED="1593745252658" ID="ID_a6a9b955bb0a" MODIFIED="1593745252658" TEXT="功能"><node CREATED="1593745252658" ID="ID_7d17f7506eeb" MODIFIED="1593745252658" TEXT="让关注点代码与业务代码分离"></node></node><node CREATED="1593745252658" ID="ID_671abe2ccd20" MODIFIED="1593745252658" TEXT="关注点"><node CREATED="1593745252658" ID="ID_ae9d46ad1e94" MODIFIED="1593745252658" TEXT="重复代码就叫做关注点"></node></node><node CREATED="1593745252658" ID="ID_816af2514e33" MODIFIED="1593745252658" TEXT="切面"><node CREATED="1593745252658" ID="ID_930feb8a771a" MODIFIED="1593745252658" TEXT="关注点形成的类，就叫切面"></node></node><node CREATED="1593745252658" ID="ID_026d5619bce4" MODIFIED="1593745252658" TEXT="切入点"><node CREATED="1593745252658" ID="ID_f330e649a9ee" MODIFIED="1593745252658" TEXT="执行目标对象方法，动态植入切面代码"></node><node CREATED="1593745252658" ID="ID_41f307f0828e" MODIFIED="1593745252658" TEXT="可以通过切入点表达式，指定拦截哪些类的哪些方法，给指定的类在运行的时候植入切面类代码"></node></node></node><node CREATED="1593745252658" ID="ID_db4ea80f3802" MODIFIED="1593745252658" TEXT="bean"><node CREATED="1593745252658" ID="ID_4c3cda82735a" MODIFIED="1593745252658" TEXT="bean的作用域"><node CREATED="1593745252658" ID="ID_f223d07aea9c" MODIFIED="1593745252658" TEXT="singleton"></node><node CREATED="1593745252658" ID="ID_1ea582aa6b02" MODIFIED="1593745252658" TEXT="prototype"></node><node CREATED="1593745252658" ID="ID_0e4ac67778e0" MODIFIED="1593745252658" TEXT="request"></node><node CREATED="1593745252658" ID="ID_d20798b83387" MODIFIED="1593745252658" TEXT="session"></node><node CREATED="1593745252658" ID="ID_4e4516939350" MODIFIED="1593745252658" TEXT="globalSession"></node></node><node CREATED="1593745252658" ID="ID_86bc2d100056" MODIFIED="1593745252658" TEXT="bean的实例化流程"><node CREATED="1593745252658" ID="ID_70facddd0bf0" MODIFIED="1593745252658" TEXT="实例化bean对象"></node><node CREATED="1593745252658" ID="ID_dec86117e42e" MODIFIED="1593745252658" TEXT="设置对象属性"></node><node CREATED="1593745252658" ID="ID_9f308c56f894" MODIFIED="1593745252658" TEXT="检查Aware相关接口并设置相关依赖"></node><node CREATED="1593745252658" ID="ID_52575c1f9287" MODIFIED="1593745252658" TEXT="BeanPostProcessor前置处理"></node><node CREATED="1593745252658" ID="ID_6a6bd697d4cb" MODIFIED="1593745252658" TEXT="检查是否是InitializingBean以决定是否调用afterPropertiesSet方法"></node><node CREATED="1593745252658" ID="ID_5a6d756d764c" MODIFIED="1593745252658" TEXT="检查是否配置有自定义的init-method"></node><node CREATED="1593745252658" ID="ID_363565adba39" MODIFIED="1593745252658" TEXT="BeanPostProcessor后置处理"></node><node CREATED="1593745252658" ID="ID_3cbf162f10cf" MODIFIED="1593745252658" TEXT="注册必要的Destruction相关回调接口"></node><node CREATED="1593745252658" ID="ID_7171bdae3a9f" MODIFIED="1593745252658" TEXT="使用"></node><node CREATED="1593745252658" ID="ID_d06f8287ba18" MODIFIED="1593745252658" TEXT="是否实现DisposableBean接口"></node><node CREATED="1593745252658" ID="ID_ad99ec8d77c3" MODIFIED="1593745252658" TEXT="是否配置有自定义的destroy方法"></node></node><node CREATED="1593745252658" ID="ID_f4037bf4d3e3" MODIFIED="1593745252658" TEXT="bean的生命周期"><node CREATED="1593745252658" ID="ID_94978d222a72" MODIFIED="1593745252658" TEXT="创建(调用构造函数)"></node><node CREATED="1593745252658" ID="ID_c13228b97031" MODIFIED="1593745252658" TEXT="set方法注入属性"></node><node CREATED="1593745252658" ID="ID_a8394b6b0148" MODIFIED="1593745252658" TEXT="BeanNameAware"></node><node CREATED="1593745252658" ID="ID_9bacfbeade44" MODIFIED="1593745252658" TEXT="BeanFactoryAware"></node><node CREATED="1593745252658" ID="ID_d78f4a3f996b" MODIFIED="1593745252658" TEXT="ApplicationContextAware"></node><node CREATED="1593745252658" ID="ID_a7b77d20bccc" MODIFIED="1593745252658" TEXT="BeanPostProcessor的before方法"></node><node CREATED="1593745252659" ID="ID_4a98fe7a6ddd" MODIFIED="1593745252659" TEXT="InitalizingBean"></node><node CREATED="1593745252659" ID="ID_65ea22cfb776" MODIFIED="1593745252659" TEXT="自定义init方法"></node><node CREATED="1593745252659" ID="ID_442c5d868837" MODIFIED="1593745252659" TEXT="BeanPostProcessor的after方法"></node><node CREATED="1593745252659" ID="ID_9152c32b9773" MODIFIED="1593745252659" TEXT="使用"></node><node CREATED="1593745252659" ID="ID_26f0d9d3265d" MODIFIED="1593745252659" TEXT="容器的销毁"></node><node CREATED="1593745252659" ID="ID_b4916ee70565" MODIFIED="1593745252659" TEXT="DisposableBean的destroy"></node><node CREATED="1593745252659" ID="ID_b215895f1ecb" MODIFIED="1593745252659" TEXT="自定义的销毁方法"></node></node></node></node><node CREATED="1593745252659" ID="ID_83b85af6e928" MODIFIED="1593745252659" TEXT="Mybatis"><node CREATED="1593745252659" ID="ID_703d21a65209" MODIFIED="1593745252659" TEXT="运行过程"><node CREATED="1593745252659" ID="ID_a4fe6ad5776c" MODIFIED="1593745252659" TEXT="读取配置文件的Configuration对象，用于创建SqlSessionFactory"></node><node CREATED="1593745252659" ID="ID_a321910866df" MODIFIED="1593745252659" TEXT="构建SqlSessionFactory"></node></node><node CREATED="1593745252659" ID="ID_4deb27838125" MODIFIED="1593745252659" TEXT="缓存"><node CREATED="1593745252659" ID="ID_de1264935792" MODIFIED="1593745252659" TEXT="一级缓存"><node CREATED="1593745252659" ID="ID_bba59676eafa" MODIFIED="1593745252659" TEXT="基于sqlSession"></node></node><node CREATED="1593745252659" ID="ID_edfec01bb87a" MODIFIED="1593745252659" TEXT="二级缓存"><node CREATED="1593745252659" ID="ID_e5b0a14da878" MODIFIED="1593745252659" TEXT="基于mapper文件的namespace，多个sqlSession可以共享一个mapper中的二级缓存区域"></node><node CREATED="1593745252659" ID="ID_71f4cc92e265" MODIFIED="1593745252659" TEXT="如果多个mapper的namespace相同，即使是多个mapper，那么这几个mapper中执行sql查询到的数据也将在相同的二级缓存区域"></node></node></node></node></node><node CREATED="1593745252659" ID="ID_b88549ae22eb" POSITION="right" MODIFIED="1593745252659" TEXT="项目"><node CREATED="1593745252659" ID="ID_e3fc2bb77f83" MODIFIED="1593745252659" TEXT="主从不一致扫描"><node CREATED="1593745252659" ID="ID_3c6eaae00780" MODIFIED="1593745252659" TEXT="问题"><node CREATED="1593745252659" ID="ID_ce76057bd6dd" MODIFIED="1593745252659" TEXT="交易那有个集群有部分key主从不一致，key数量非常大，主从结果复杂"></node></node><node CREATED="1593745252659" ID="ID_b630a31870a4" MODIFIED="1593745252659" TEXT="开发考虑"><node CREATED="1593745252659" ID="ID_ca195d8a6793" MODIFIED="1593745252659" TEXT="key数量大，采用多线程"><node CREATED="1593745252659" ID="ID_1f6a715eabbf" MODIFIED="1593745252659" TEXT="forkjoinpool"></node></node><node CREATED="1593745252659" ID="ID_ad6c726b8e90" MODIFIED="1593745252659" TEXT="对ops要求高，多参数限制"><node CREATED="1593745252659" ID="ID_d3f61348f26f" MODIFIED="1593745252659" TEXT="scanMaster"><node CREATED="1593745252659" ID="ID_4efb19232203" MODIFIED="1593745252659" TEXT="避免对线上的影响，不扫主"></node></node><node CREATED="1593745252659" ID="ID_9f3dbcd32a12" MODIFIED="1593745252659" TEXT="count"><node CREATED="1593745252659" ID="ID_6500e15a3e79" MODIFIED="1593745252659" TEXT="一次取出来的key的数量"></node></node><node CREATED="1593745252659" ID="ID_ef259e57246d" MODIFIED="1593745252659" TEXT="sleepTime"><node CREATED="1593745252659" ID="ID_14e5fc2edb47" MODIFIED="1593745252659" TEXT="扫描完每个槽位后的等待时间"></node></node><node CREATED="1593745252659" ID="ID_60c8fd012d7b" MODIFIED="1593745252659" TEXT="threadSleepTime&amp;lt;br&amp;gt;"><node CREATED="1593745252659" ID="ID_aca68c7f29f9" MODIFIED="1593745252659" TEXT="每个线程的执行等待时间&amp;lt;br&amp;gt;"></node></node></node><node CREATED="1593745252659" ID="ID_917c9cf77924" MODIFIED="1593745252659" TEXT="主从同步延迟"><node CREATED="1593745252659" ID="ID_5f1fd95ebc40" MODIFIED="1593745252659" TEXT="waitSyncTime"><node CREATED="1593745252659" ID="ID_630ac693f969" MODIFIED="1593745252659" TEXT="等待同步时间，如果扫描两个实例后，有不同的key，先等一会，等待同步，再次扫描确认"></node></node></node><node CREATED="1593745252659" ID="ID_3ea4cdaca2c4" MODIFIED="1593745252659" TEXT="内存泄漏"><node CREATED="1593745252659" ID="ID_e3181d6ea4b3" MODIFIED="1593745252659" TEXT="多个线程，每个线程保持一组连接，需要全部关掉"><node CREATED="1593745252659" ID="ID_466383e04b2a" MODIFIED="1593745252659" TEXT="每个线程通过threadlocal保存一组连接，保证连接重复使用"></node></node></node><node CREATED="1593745252659" ID="ID_ab8f96696ab5" MODIFIED="1593745252659" TEXT="jedis操作redis的时候，对底层执行redis命令做了缓存，所以如果某一次redis操作出现异常，jedis实例中的缓存数据不会被清空，而直接放回连接池中。下一次从池中取出了同一个jedis对象，发送的命令用的还是上一个线程的数据&amp;lt;br&amp;gt;"></node><node CREATED="1593745252659" ID="ID_788cf9a3a2dc" MODIFIED="1593745252659" TEXT="暂停"></node></node></node><node CREATED="1593745252659" ID="ID_044e66d34def" MODIFIED="1593745252659" TEXT="failover"><node CREATED="1593745252659" ID="ID_fe16eceef0a9" MODIFIED="1593745252659" TEXT="sentinel检测实例，有半数以上报告故障，持续一段时间&amp;lt;br&amp;gt;"></node><node CREATED="1593745252659" ID="ID_d33e932407d1" MODIFIED="1593745252659" TEXT="将故障实例放入故障池，通过cm补缺失实例&amp;lt;br&amp;gt;"></node><node CREATED="1593745252659" ID="ID_8df45c3c1a76" MODIFIED="1593745252659" TEXT="将新拓扑结构更新到cfs"></node><node CREATED="1593745252659" ID="ID_cc7483182ec7" MODIFIED="1593745252659" TEXT="客户端 拉取配置信息"></node></node><node CREATED="1593745252659" ID="ID_2b5deeb2c5f2" MODIFIED="1593745252659" TEXT="日常问题"><node CREATED="1593745252659" ID="ID_b9840f9ab46d" MODIFIED="1593745252659" TEXT="某个指令ops远低于预期"><node CREATED="1593745252659" ID="ID_cdf3b6d25cb8" MODIFIED="1593745252659" TEXT="先质疑，问怎么埋点"></node><node CREATED="1593745252659" ID="ID_be28b1c492a8" MODIFIED="1593745252659" TEXT="查看指令，有些特殊的指令，例如synIncr等同步指令，效率低"></node><node CREATED="1593745252659" ID="ID_6e15ee4bbcf5" MODIFIED="1593745252659" TEXT="是否是大key的问题"></node><node CREATED="1593745252659" ID="ID_676eec23dbf9" MODIFIED="1593745252659" TEXT="是否存在跨机房访问"></node></node><node CREATED="1593745252659" ID="ID_9d1cbc2be74d" MODIFIED="1593745252659" TEXT="moved问题"><node CREATED="1593745252659" ID="ID_737b57ecd8bb" MODIFIED="1593745252659" TEXT="检查该实例是否存在执行中断的迁移任务"></node></node></node></node><node CREATED="1593745252659" ID="ID_e36557f07ffa" POSITION="right" MODIFIED="1593745252659" TEXT="消息队列"><node CREATED="1593745252659" ID="ID_37a95e5c10b3" MODIFIED="1593745252659" TEXT="为什么要使用消息队列"><node CREATED="1593745252659" ID="ID_a5224e28ac0e" MODIFIED="1593745252659" TEXT="通过异步处理提高系统性能(削峰、减少响应所需时间)"><node CREATED="1593745252659" ID="ID_a410e7544828" MODIFIED="1593745252659" TEXT="在不使用消息队列服务器的时候，用户的请求数据直接写入数据库，在高并发的情况下数据库压力剧增，使得响应速度变慢。但是在使用消息队列之后，用户的请求数据发送给消息队列之后立即 返回，再由消息队列的消费者进程从消息队列中获取数据，异步写入数据库。由于消息队列服务器处理速度快于数据库（消息队列也比数据库有更好的伸缩性），因此响应速度得到大幅改善&amp;lt;br&amp;gt;"></node><node CREATED="1593745252659" ID="ID_e3a65387d10d" MODIFIED="1593745252659" TEXT="因为用户请求数据写入消息队列之后就立即返回给用户了，但是请求数据在后续的业务校验、写数据库等操作中可能失败。因此使用消息队列进行异步处理之后，需要适当修改业务流程进行配合，比如用户在提交订单之后，订单数据写入消息队列，不能立即返回用户订单提交成功，需要在消息队列的订单消费者进程真正处理完该订单之后，甚至出库后，再通过电子邮件或短信通知用户订单成功，以免交易纠纷。&amp;lt;br&amp;gt;"></node></node><node CREATED="1593745252659" ID="ID_f672e721d6d0" MODIFIED="1593745252659" TEXT="降低系统耦合度"><node CREATED="1593745252659" ID="ID_7989aeb0dfb3" MODIFIED="1593745252659" TEXT="消息发送者（生产者）和消息接受者（消费者）之间没有直接耦合，消息发送者将消息发送至分布式消息队列即结束对消息的处理，消息接受者从分布式消息队列获取该消息后进行后续处理，并不需要知道该消息从何而来"></node><node CREATED="1593745252659" ID="ID_3254e22a27e6" MODIFIED="1593745252659" TEXT="为了避免消息队列服务器宕机造成消息丢失，会将成功发送到消息队列的消息存储在消息生产者服务器上，等消息真正被消费者服务器处理后才删除消息。在消息队列服务器宕机后，生产者服务器会选择分布式消息队列服务器集群中的其他服务器发布消息"></node></node></node><node CREATED="1593745252659" ID="ID_bd54cea90df1" MODIFIED="1593745252659" TEXT="使用消息队列带来的问题"><node CREATED="1593745252659" ID="ID_6016155ff619" MODIFIED="1593745252659" TEXT="系统可用性降低"><node CREATED="1593745252659" ID="ID_96c0adb5836a" MODIFIED="1593745252659" TEXT="系统可用性在某种程度上降低了，在加入MQ之前，不用考虑消息丢失或者MQ挂掉的情况"></node></node><node CREATED="1593745252659" ID="ID_6bac179eafe2" MODIFIED="1593745252659" TEXT="系统复杂性提高"><node CREATED="1593745252659" ID="ID_295892f2435a" MODIFIED="1593745252659" TEXT="加入MQ之后，需要保证消息没有被重复消费、处理消息丢失的情况和暴增消息传递的顺序性"></node></node><node CREATED="1593745252659" ID="ID_e7329a30f796" MODIFIED="1593745252659" TEXT="一致性问题"><node CREATED="1593745252659" ID="ID_8c2eb1153a0b" MODIFIED="1593745252659" TEXT="由于消息队列实现异步，会导致消息的真正消费者并没有正确消费消息"></node></node></node></node><node CREATED="1593745252659" ID="ID_066d0a91127e" POSITION="right" MODIFIED="1593745252659" TEXT="数据库"><node CREATED="1593745252659" ID="ID_389ffb0ce66e" MODIFIED="1593745252659" TEXT="索引"><node CREATED="1593745252659" ID="ID_068bb3075daf" MODIFIED="1593745252659" TEXT="什么是索引"><node CREATED="1593745252659" ID="ID_b8e19da1ddc0" MODIFIED="1593745252659" TEXT="是一种快速查询表中内容的机制"></node><node CREATED="1593745252659" ID="ID_8ff4e8472c6e" MODIFIED="1593745252659" TEXT="运用在表中某些字段上，存储时，独立于表之外"></node></node><node CREATED="1593745252659" ID="ID_a6a85035e4ca" MODIFIED="1593745252659" TEXT="为什么使用索引"><node CREATED="1593745252659" ID="ID_94f69278a558" MODIFIED="1593745252659" TEXT="索引可以加快数据库的检索速度"></node></node><node CREATED="1593745252659" ID="ID_85444da61ae6" MODIFIED="1593745252659" TEXT="为什么索引可以加快查询速度"><node CREATED="1593745252659" ID="ID_d330b1adff70" MODIFIED="1593745252659" TEXT="将无序的数据变成有序"></node></node><node CREATED="1593745252659" ID="ID_e386789ee3f9" MODIFIED="1593745252659" TEXT="为什么增删改会降低速度"><node CREATED="1593745252659" ID="ID_0104a430f21d" MODIFIED="1593745252659" TEXT="索引的页是B+树实现的，即平衡树的一种"></node><node CREATED="1593745252659" ID="ID_c170a0407ae3" MODIFIED="1593745252659" TEXT="对树进行增删改会破坏原有结构，为了维持平衡树，就必须做额外的工作"></node></node><node CREATED="1593745252659" ID="ID_3cb0e41d5e31" MODIFIED="1593745252659" TEXT="什么情况下使用索引"><node CREATED="1593745252659" ID="ID_dbd6f52fc61c" MODIFIED="1593745252659" TEXT="表经常进行查询操作要建立索引"></node><node CREATED="1593745252659" ID="ID_f68cefaa05cd" MODIFIED="1593745252659" TEXT="表很大，记录内容分布范围很广"></node><node CREATED="1593745252659" ID="ID_e9774e7291b1" MODIFIED="1593745252659" TEXT="列名经常在WHERE子句或连接条件中出现"></node><node CREATED="1593745252659" ID="ID_652bd768fd10" MODIFIED="1593745252659" TEXT="表经常进行 INSERT/UPDATA/DELETE操作不要建立索引，索引会较低插入、删除、修改的速度"></node><node CREATED="1593745252659" ID="ID_b3966ebdf751" MODIFIED="1593745252659" TEXT="表较小的时候，不建立索引，索引会占物理和数据空间"></node></node><node CREATED="1593745252659" ID="ID_6935a5c7f92e" MODIFIED="1593745252659" TEXT="索引的最左匹配原则"><node CREATED="1593745252659" ID="ID_174d6ca9c740" MODIFIED="1593745252659" TEXT="对于单索引来说，索引是有序排列的数据结构"></node><node CREATED="1593745252659" ID="ID_d630fea7b4aa" MODIFIED="1593745252659" TEXT="&amp;nbsp;对于复合索引来说，索引对最左边的数据进行排序，然后再第一个字段的基础上，对第二个字段进行排序"></node><node CREATED="1593745252659" ID="ID_609a5fcd9b15" MODIFIED="1593745252659" TEXT="也就是为了使用第二个索引，应先使用第一个索引，且第一个索引是等值匹配"></node></node><node CREATED="1593745252659" ID="ID_638c7b906031" MODIFIED="1593745252659" TEXT="聚集索引和非聚集索引"><node CREATED="1593745252659" ID="ID_7f2511dc871b" MODIFIED="1593745252659" TEXT="聚集索引是以主键创建的索引，聚集索引的物理存储位置与索引的逻辑顺序有关，一个表中只能有一个聚集索引"></node><node CREATED="1593745252659" ID="ID_c8f12aa1cb60" MODIFIED="1593745252659" TEXT="非聚集索引是以非主键创建的索引"><node CREATED="1593745252659" ID="ID_c28f09cc1729" MODIFIED="1593745252659" TEXT="一个表中可以有多个非聚集索引"></node></node><node CREATED="1593745252659" ID="ID_b34b8ccf2f10" MODIFIED="1593745252659" TEXT="二者区别"><node CREATED="1593745252659" ID="ID_f694b7c3126e" MODIFIED="1593745252659" TEXT="聚集索引在叶子结点存储的是表中的数据"></node><node CREATED="1593745252659" ID="ID_b1f683581f63" MODIFIED="1593745252659" TEXT="非聚集索引在叶子节点存储的是主键和索引列"></node><node CREATED="1593745252659" ID="ID_f4c6dd2d1bef" MODIFIED="1593745252659" TEXT="使用非聚集索引查询出数据时，拿到叶子上的主键再去查询想要的数据（回表）"></node></node></node><node CREATED="1593745252659" ID="ID_13680d5e86ab" MODIFIED="1593745252659" TEXT="建立索引的原则"><node CREATED="1593745252659" ID="ID_fcaacd84a078" MODIFIED="1593745252659" TEXT="最左匹配原则"><node CREATED="1593745252659" ID="ID_a00574321a53" MODIFIED="1593745252659" TEXT="MySql会一直向右匹配直到遇到范围查询"></node></node><node CREATED="1593745252659" ID="ID_0caf93de26f3" MODIFIED="1593745252659" TEXT="选择区分度高的列作为索引"></node><node CREATED="1593745252659" ID="ID_c3786fb30417" MODIFIED="1593745252659" TEXT="尽可能的扩展索引，不要新建立索引"></node><node CREATED="1593745252659" ID="ID_62b82e9a83d0" MODIFIED="1593745252659" TEXT="单个多列组合索引和多个单列索引的检索查询效果不同"><node CREATED="1593745252659" ID="ID_f18d20909abc" MODIFIED="1593745252659" TEXT="MySql在执行SQL时，只能使用一个索引，会从多个单列索引中选择一个限制最为严格的索引"></node></node></node><node CREATED="1593745252659" ID="ID_cb3be6146dd5" MODIFIED="1593745252659" TEXT="索引失效"><node CREATED="1593745252659" ID="ID_5d852a16d73c" MODIFIED="1593745252659" TEXT="对索引进行运算"></node><node CREATED="1593745252659" ID="ID_b5b3ae1eebaa" MODIFIED="1593745252659" TEXT="单独使用复合索引非第一位置的索引"></node><node CREATED="1593745252659" ID="ID_35fe4905d3df" MODIFIED="1593745252659" TEXT="字符型索引为数字时在where条件里不添加引号"></node><node CREATED="1593745252659" ID="ID_6a50137711b7" MODIFIED="1593745252659" TEXT="where子句中有 !=判断"></node><node CREATED="1593745252659" ID="ID_2bd0505cec98" MODIFIED="1593745252659" TEXT="where子句中有null值"></node></node><node CREATED="1593745252659" ID="ID_8409923c9723" MODIFIED="1593745252659" TEXT="为什么索引用B+树而不是B树"><node CREATED="1593745252659" ID="ID_aa1f164a6f96" MODIFIED="1593745252659" TEXT="B+树的数据都集中在叶子节点。分支节点只负责索引。B树的分支节点也有数据，B+树的层高会小于B树"></node><node CREATED="1593745252659" ID="ID_c6b4e3971216" MODIFIED="1593745252659" TEXT="B+树更擅长范围查询，叶子节点用顺序访问指针实现。B+树范围查询只能中序遍历"></node><node CREATED="1593745252659" ID="ID_61de58437915" MODIFIED="1593745252659" TEXT="索引节点没有数据，比较小"></node></node><node CREATED="1593745252659" ID="ID_8c6947a2613a" MODIFIED="1593745252659" TEXT="为什么索引不用红黑树"><node CREATED="1593745252659" ID="ID_53af5b57c025" MODIFIED="1593745252659" TEXT="数据多的话树太长太高&amp;lt;br&amp;gt;"></node></node></node><node CREATED="1593745252659" ID="ID_3db189d38f8f" MODIFIED="1593745252659" TEXT="锁"><node CREATED="1593745252659" ID="ID_d1e9a11f208d" MODIFIED="1593745252659" TEXT="表锁"><node CREATED="1593745252659" ID="ID_8740cdc76d80" MODIFIED="1593745252659" TEXT="开销小，加锁快"></node><node CREATED="1593745252659" ID="ID_4f2961796ddd" MODIFIED="1593745252659" TEXT="不会出现死锁"></node><node CREATED="1593745252659" ID="ID_463c0e1eb4da" MODIFIED="1593745252659" TEXT="锁定粒度大，发生锁冲突概率高，并发度最低"></node></node><node CREATED="1593745252659" ID="ID_5978313780de" MODIFIED="1593745252659" TEXT="行锁"><node CREATED="1593745252659" ID="ID_4e26764ac0e0" MODIFIED="1593745252659" TEXT="开销大，加锁慢"></node><node CREATED="1593745252659" ID="ID_d429e9110b9a" MODIFIED="1593745252659" TEXT="会出现死锁"></node><node CREATED="1593745252659" ID="ID_675ee7aa25bd" MODIFIED="1593745252659" TEXT="锁定粒度小，发生锁冲突的概率低，并发度低"></node></node><node CREATED="1593745252659" ID="ID_4e83bbc887f2" MODIFIED="1593745252659" TEXT="共享锁（读锁）"><node CREATED="1593745252659" ID="ID_fa912dbca6f5" MODIFIED="1593745252659" TEXT="允许一个事务去读一行，阻止其他事务获得相同的排他锁"></node><node CREATED="1593745252659" ID="ID_685a9258154b" MODIFIED="1593745252659" TEXT="多个客户可以同时读取同一个资源，但不允许其他客户修改"></node></node><node CREATED="1593745252659" ID="ID_973ac0a43afd" MODIFIED="1593745252659" TEXT="排他锁（写锁）"><node CREATED="1593745252659" ID="ID_75462acb7696" MODIFIED="1593745252659" TEXT="允许获得排他锁的事务更新数据，组织其他事务取得相同数据集的共享读锁和排他写锁"></node><node CREATED="1593745252659" ID="ID_3a78f16f7103" MODIFIED="1593745252659" TEXT="写锁是排他的，写锁会阻塞其他的写锁和读锁"></node></node><node CREATED="1593745252659" ID="ID_030ba836e1ef" MODIFIED="1593745252659" TEXT="间隙锁GAP"><node CREATED="1593745252659" ID="ID_966952b432ae" MODIFIED="1593745252659" TEXT="间隙锁只在Repeatable read隔离级别下使用"></node><node CREATED="1593745252659" ID="ID_f99e05a9bbb9" MODIFIED="1593745252659" TEXT="在用范围条件检索数据并请求共享或排他锁，对于键值在条件范围内但并不存在的记录，也会加锁"></node><node CREATED="1593745252659" ID="ID_a8d1332dd0e7" MODIFIED="1593745252659" TEXT="作用："><node CREATED="1593745252659" ID="ID_39bfe86b0dc6" MODIFIED="1593745252659" TEXT="防止幻读"></node><node CREATED="1593745252659" ID="ID_9f9a4c186ab2" MODIFIED="1593745252659" TEXT="满足恢复和复制的需要"><node CREATED="1593745252659" ID="ID_2af1afd7f391" MODIFIED="1593745252659" TEXT="在一个事务未提交前，其他并发事务不能插入满足其锁定条件的任何记录"></node></node></node></node><node CREATED="1593745252659" ID="ID_38ffcf34797c" MODIFIED="1593745252659" TEXT="死锁"><node CREATED="1593745252659" ID="ID_c3711197442a" MODIFIED="1593745252659" TEXT="避免死锁的方式"><node CREATED="1593745252660" ID="ID_44a39271f586" MODIFIED="1593745252660" TEXT="以固定的顺序访问表和行"></node><node CREATED="1593745252660" ID="ID_f8b141086700" MODIFIED="1593745252660" TEXT="大事务拆小"></node><node CREATED="1593745252660" ID="ID_b142fe8a4ced" MODIFIED="1593745252660" TEXT="在同一事务中，尽可能做到一次锁定所需要的所有资源，减少死锁概率"></node><node CREATED="1593745252660" ID="ID_7f78861a2718" MODIFIED="1593745252660" TEXT="降低隔离级别"></node><node CREATED="1593745252660" ID="ID_673bd073a526" MODIFIED="1593745252660" TEXT="为表添加合理的索引"><node CREATED="1593745252660" ID="ID_ef3bb8fd33ea" MODIFIED="1593745252660" TEXT="不走索引将会为表的每一行记录添加上锁，死锁的概率大大增加"></node></node></node></node><node CREATED="1593745252660" ID="ID_ea70c8a74e75" MODIFIED="1593745252660" TEXT="丢失更新"><node CREATED="1593745252660" ID="ID_78b8c96dbe87" MODIFIED="1593745252660" TEXT="一个事务的更新覆盖了其他事务的更新结果"></node><node CREATED="1593745252660" ID="ID_3ef58ea22ba5" MODIFIED="1593745252660" TEXT="解决方法"><node CREATED="1593745252660" ID="ID_8de201ee0a2a" MODIFIED="1593745252660" TEXT="使用Serializable隔离级别，事务是串行执行的"></node><node CREATED="1593745252660" ID="ID_ee338492b4a3" MODIFIED="1593745252660" TEXT="乐观锁"><node CREATED="1593745252660" ID="ID_9163a31dfe4f" MODIFIED="1593745252660" TEXT="表中有一个版本字段，第一次读的时候，获取到这个字段。当更新时，再次查看该字段的值是否和第一次一样，如果一样更新，反之拒绝"></node><node CREATED="1593745252660" ID="ID_398bb19f4f10" MODIFIED="1593745252660" TEXT="实现方式"><node CREATED="1593745252660" ID="ID_fe7774dc067c" MODIFIED="1593745252660" TEXT="加version版本字段"></node></node></node><node CREATED="1593745252660" ID="ID_47924741b4ee" MODIFIED="1593745252660" TEXT="悲观锁"><node CREATED="1593745252660" ID="ID_0a8d42d21b4a" MODIFIED="1593745252660" TEXT="悲观锁是数据库层面的加锁，每次操作都会阻塞去等待锁"></node><node CREATED="1593745252660" ID="ID_4beadd9cc98d" MODIFIED="1593745252660" TEXT="实现方式"><node CREATED="1593745252660" ID="ID_90c386a5fd2c" MODIFIED="1593745252660" TEXT="手动加行锁"><node CREATED="1593745252660" ID="ID_6f5d64b2a30f" MODIFIED="1593745252660" TEXT="例如：select * from xx for update"></node><node CREATED="1593745252660" ID="ID_48c1c32a3be1" MODIFIED="1593745252660" TEXT="在select语句后面加了 for update 相当于加了排他锁,加了写锁以后，其他的事务就不能对它修改了，需要等待当前事务修改完之后"></node></node></node></node><node CREATED="1593745252660" ID="ID_237d9037e499" MODIFIED="1593745252660" TEXT="乐观锁和悲观锁的应用场景"><node CREATED="1593745252660" ID="ID_4bd85306a467" MODIFIED="1593745252660" TEXT="乐观锁使用于多读场景(写比较少)，即冲突很少发生的时候"></node><node CREATED="1593745252660" ID="ID_476151802496" MODIFIED="1593745252660" TEXT="悲观锁使用于多写场景，容易发生冲突的场景"></node></node></node></node><node CREATED="1593745252660" ID="ID_b70dcb0f0f56" MODIFIED="1593745252660" TEXT="for update"><node CREATED="1593745252660" ID="ID_f39cafdf6bde" MODIFIED="1593745252660" TEXT="使用到索引"><node CREATED="1593745252660" ID="ID_8b441a55467a" MODIFIED="1593745252660" TEXT="有数据"><node CREATED="1593745252660" ID="ID_4d956d2fe19a" MODIFIED="1593745252660" TEXT="行锁"></node></node><node CREATED="1593745252660" ID="ID_87eada2829ad" MODIFIED="1593745252660" TEXT="无数据"><node CREATED="1593745252660" ID="ID_26522be121ed" MODIFIED="1593745252660" TEXT="不加锁"></node></node></node><node CREATED="1593745252660" ID="ID_98861f968ba5" MODIFIED="1593745252660" TEXT="没有使用到索引"><node CREATED="1593745252660" ID="ID_a58097d7372d" MODIFIED="1593745252660" TEXT="有数据"><node CREATED="1593745252660" ID="ID_85e2a3caaaac" MODIFIED="1593745252660" TEXT="表锁"></node></node><node CREATED="1593745252660" ID="ID_cde713362abc" MODIFIED="1593745252660" TEXT="无数据"><node CREATED="1593745252660" ID="ID_11c88d7b5a35" MODIFIED="1593745252660" TEXT="不加锁"></node></node></node></node></node><node CREATED="1593745252660" ID="ID_ff1f4c2df8d5" MODIFIED="1593745252660" TEXT="事务"><node CREATED="1593745252660" ID="ID_47ccb0eca9e5" MODIFIED="1593745252660" TEXT="什么是事务"><node CREATED="1593745252660" ID="ID_ccbc5533fdb1" MODIFIED="1593745252660" TEXT="满足ACID"></node></node><node CREATED="1593745252660" ID="ID_e05e6996ca24" MODIFIED="1593745252660" TEXT="事务特性"><node CREATED="1593745252660" ID="ID_57fe4f7d1852" MODIFIED="1593745252660" TEXT="原子性"></node><node CREATED="1593745252660" ID="ID_7b7c8ee36b1a" MODIFIED="1593745252660" TEXT="一致性"></node><node CREATED="1593745252660" ID="ID_a08b2c625fe3" MODIFIED="1593745252660" TEXT="隔离性"></node><node CREATED="1593745252660" ID="ID_647c50642c5a" MODIFIED="1593745252660" TEXT="持久性"></node></node><node CREATED="1593745252660" ID="ID_acff992edb8c" MODIFIED="1593745252660" TEXT="事务隔离级别"><node CREATED="1593745252660" ID="ID_53684ab2031c" MODIFIED="1593745252660" TEXT="Serializable"><node CREATED="1593745252660" ID="ID_97ff1cb938ee" MODIFIED="1593745252660" TEXT="可避免脏读，不可重复读，虚读"></node></node><node CREATED="1593745252660" ID="ID_ba7cf29846da" MODIFIED="1593745252660" TEXT="Repeatable read"><node CREATED="1593745252660" ID="ID_7d3e2d753a2d" MODIFIED="1593745252660" TEXT="可避免脏读，不可重复读"></node></node><node CREATED="1593745252660" ID="ID_1408fec7f2e3" MODIFIED="1593745252660" TEXT="Read committed"><node CREATED="1593745252660" ID="ID_298188b3947e" MODIFIED="1593745252660" TEXT="可避免脏读"></node></node><node CREATED="1593745252660" ID="ID_66c89ef93cd0" MODIFIED="1593745252660" TEXT="Read uncommitted"><node CREATED="1593745252660" ID="ID_2f1a78cdaac8" MODIFIED="1593745252660" TEXT="级别最低，什么都避免不了"></node></node></node><node CREATED="1593745252660" ID="ID_32dcf188c95f" MODIFIED="1593745252660" TEXT="脏读、不可重复读、虚读(幻读)"><node CREATED="1593745252660" ID="ID_db614bae7453" MODIFIED="1593745252660" TEXT="脏读"><node CREATED="1593745252660" ID="ID_17d0ef238ddf" MODIFIED="1593745252660" TEXT="脏读就是指当事务A对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务B也访问这个数据，然后使用了这个数据。"></node></node><node CREATED="1593745252660" ID="ID_e33a573008c9" MODIFIED="1593745252660" TEXT="不可重复读"><node CREATED="1593745252660" ID="ID_8b4f832aacc5" MODIFIED="1593745252660" TEXT="不可重复读是指在事务1内，读取了一个数据，事务1还没有结束时，事务2也访问了这个数据，修改了这个数据，并提交。紧接着，事务1又读这个数据。由于事务2的修改，那么事务1两次读到的的数据可能是不一样的，因此称为是不可重复读。"></node></node><node CREATED="1593745252660" ID="ID_3c36b9c64b99" MODIFIED="1593745252660" TEXT="虚读"><node CREATED="1593745252660" ID="ID_2613e981392e" MODIFIED="1593745252660" TEXT="所谓幻读，指的是当某个事务在读取某个范围内的记录时，另外一个事务又在该范围内插入了新的记录，当之前的事务再次读取该范围的记录时，会产生幻行。InnoDB存储引擎通过多版本并发控制（MVCC）解决了幻读的问题。"></node></node></node></node><node CREATED="1593745252660" ID="ID_08d775a32157" MODIFIED="1593745252660" TEXT="存储过程"><node CREATED="1593745252660" ID="ID_9636806f8a11" MODIFIED="1593745252660" TEXT="优点"><node CREATED="1593745252660" ID="ID_5e99766c2224" MODIFIED="1593745252660" TEXT="能够将代码封装起来"></node><node CREATED="1593745252660" ID="ID_1b1da3432b38" MODIFIED="1593745252660" TEXT="保存在数据库之中"></node><node CREATED="1593745252660" ID="ID_51631f855c82" MODIFIED="1593745252660" TEXT="让编程语言进行调用"></node><node CREATED="1593745252660" ID="ID_07559ab89b28" MODIFIED="1593745252660" TEXT="存储过程是一个预编译的代码块，并行效率比较高"></node><node CREATED="1593745252660" ID="ID_2cc920156fd2" MODIFIED="1593745252660" TEXT="一个存储过程替代大量T_SQL语句，可以降低网络通信量，提高通信速率"></node></node><node CREATED="1593745252660" ID="ID_f96b42ef2141" MODIFIED="1593745252660" TEXT="缺点"><node CREATED="1593745252660" ID="ID_3401d2d22021" MODIFIED="1593745252660" TEXT="每个数据库的存储语法几乎都不一样，十分难以维护"></node><node CREATED="1593745252660" ID="ID_5602a2d889ae" MODIFIED="1593745252660" TEXT="业务逻辑放在数据库上，难以迭代"></node></node></node><node CREATED="1593745252660" ID="ID_fb02b25122d5" MODIFIED="1593745252660" TEXT="三个范式"><node CREATED="1593745252660" ID="ID_7ae60c2fe3c2" MODIFIED="1593745252660" TEXT="第一范式"><node CREATED="1593745252660" ID="ID_b2f8167e1d8d" MODIFIED="1593745252660" TEXT="数据库表中的字段都是单一属性的，不可再分"></node></node><node CREATED="1593745252660" ID="ID_7b9e09d7d15f" MODIFIED="1593745252660" TEXT="第二范式"><node CREATED="1593745252660" ID="ID_7432570d19b7" MODIFIED="1593745252660" TEXT="满足第一范式，表中的字段必须完全依赖于全部主键而非部分主键"></node></node><node CREATED="1593745252660" ID="ID_55004a6e1880" MODIFIED="1593745252660" TEXT="第三范式"><node CREATED="1593745252660" ID="ID_ca5c60d9f0d5" MODIFIED="1593745252660" TEXT="满足第二范式，非主键外的所有字段必须互不依赖"></node></node></node><node CREATED="1593745252660" ID="ID_334646362bdd" MODIFIED="1593745252660" TEXT="视图"><node CREATED="1593745252660" ID="ID_960c344c930b" MODIFIED="1593745252660" TEXT="什么是视图"><node CREATED="1593745252660" ID="ID_9011c1056e8c" MODIFIED="1593745252660" TEXT="视图是一种虚表"></node><node CREATED="1593745252660" ID="ID_7dce781a3960" MODIFIED="1593745252660" TEXT="视图建立在已有表的基础上，视图赖以建立的这些表称为基表"></node><node CREATED="1593745252660" ID="ID_fa94f2724cb6" MODIFIED="1593745252660" TEXT="向视图提供数据内容的语句为SELECT语句，可以将视图理解为存储起来的SELECT语句"></node><node CREATED="1593745252660" ID="ID_f0abfa898534" MODIFIED="1593745252660" TEXT="视图向用户提供基表数据的另一种表现形式"></node><node CREATED="1593745252660" ID="ID_cd7007113066" MODIFIED="1593745252660" TEXT="视图没有存储真正的数据，真正的数据还是存储在基表中"></node><node CREATED="1593745252660" ID="ID_a02e930ba7ba" MODIFIED="1593745252660" TEXT="程序员虽然操作的是视图，但最终视图还会转成操作基表"></node><node CREATED="1593745252660" ID="ID_cb374d111594" MODIFIED="1593745252660" TEXT="一个基表可以有0个或多个视图"></node></node></node><node CREATED="1593745252660" ID="ID_1799e41f1d4c" MODIFIED="1593745252660" TEXT="drop、delete和truncate分别在什么场景之下使用"><node CREATED="1593745252660" ID="ID_bb64f8af9a26" MODIFIED="1593745252660" TEXT="drop"><node CREATED="1593745252660" ID="ID_3a5dd96f891a" MODIFIED="1593745252660" TEXT="不可回滚"></node><node CREATED="1593745252660" ID="ID_8330aa53cdee" MODIFIED="1593745252660" TEXT="不可带where"></node><node CREATED="1593745252660" ID="ID_7fe76983695f" MODIFIED="1593745252660" TEXT="表内容和结构删除"></node><node CREATED="1593745252660" ID="ID_6d41f626cb94" MODIFIED="1593745252660" TEXT="删除速度快"></node></node><node CREATED="1593745252660" ID="ID_9a0fc43e1bbf" MODIFIED="1593745252660" TEXT="truncate"><node CREATED="1593745252660" ID="ID_9eb173cefe5d" MODIFIED="1593745252660" TEXT="不可回滚"></node><node CREATED="1593745252660" ID="ID_d5d77954dcf1" MODIFIED="1593745252660" TEXT="不可带where"></node><node CREATED="1593745252660" ID="ID_7fece8345693" MODIFIED="1593745252660" TEXT="表内容删除"></node><node CREATED="1593745252660" ID="ID_085169ba8257" MODIFIED="1593745252660" TEXT="删除速度快"></node></node><node CREATED="1593745252660" ID="ID_dcdf61d861d5" MODIFIED="1593745252660" TEXT="delete"><node CREATED="1593745252660" ID="ID_4db451f11f80" MODIFIED="1593745252660" TEXT="可回滚"></node><node CREATED="1593745252660" ID="ID_2fc35fedbf4e" MODIFIED="1593745252660" TEXT="可带where"></node><node CREATED="1593745252660" ID="ID_c8f67290c47f" MODIFIED="1593745252660" TEXT="表结构在，表内容要看where执行的情况"></node><node CREATED="1593745252660" ID="ID_20b59f097193" MODIFIED="1593745252660" TEXT="删除速度慢，需要逐条删除"></node></node><node CREATED="1593745252660" ID="ID_45441b8b41a3" MODIFIED="1593745252660" TEXT="使用场景"><node CREATED="1593745252660" ID="ID_d69b120dbd0f" MODIFIED="1593745252660" TEXT="不在需要一张表的时候，用drop"></node><node CREATED="1593745252660" ID="ID_fe73e6bb56cb" MODIFIED="1593745252660" TEXT="想删除部分数据行的时候，用delete，并且带上where语句"></node><node CREATED="1593745252660" ID="ID_383b1b7882cd" MODIFIED="1593745252660" TEXT="保留表而删除所有数据的时候用truncate"></node></node></node><node CREATED="1593745252660" ID="ID_b301087d2af0" MODIFIED="1593745252660" TEXT="mysql中in和exists区别"><node CREATED="1593745252660" ID="ID_05253fe5993d" MODIFIED="1593745252660" TEXT="in语句把外表和内表hash连接，exists语句对外表作loop循环，每次loop循环再对内表进行查询"></node><node CREATED="1593745252660" ID="ID_7d8483e7caed" MODIFIED="1593745252660" TEXT="如果查询的两个表大小相当，那么in和exists差别不大；&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;如果两个表中一个较小，一个较大，则子查询表大的用exists，子查询表小的用in；&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;"></node><node CREATED="1593745252660" ID="ID_e5ece27d3715" MODIFIED="1593745252660" TEXT="not in 和not exists如果查询语句使用了not in 那么内外表都进行全表扫描，没有用到索引；而not exists 的子查询依然能用到表上的索引。所以无论那个表大，用not exists都比not in要快。"></node><node CREATED="1593745252660" ID="ID_4bc9fc099fef" MODIFIED="1593745252660" TEXT="EXISTS只返回TRUE或FALSE，不会返回UNKNOWN。&amp;lt;br&amp;gt;IN当遇到包含NULL的情况，那么就会返回UNKNOWN。"></node></node><node CREATED="1593745252660" ID="ID_c92ba8288fa7" MODIFIED="1593745252660" TEXT="SQL约束有哪几种"><node CREATED="1593745252660" ID="ID_ecebb345505a" MODIFIED="1593745252660" TEXT="NOT NULL"><node CREATED="1593745252660" ID="ID_4f7dda54e014" MODIFIED="1593745252660" TEXT="用于控制字段的内容一定不能为空"></node></node><node CREATED="1593745252660" ID="ID_5840c95dee7e" MODIFIED="1593745252660" TEXT="UNIQUE"><node CREATED="1593745252660" ID="ID_29df06d49bf9" MODIFIED="1593745252660" TEXT="控制字段内容不能重复，一个表允许有多个Unique约束"></node></node><node CREATED="1593745252660" ID="ID_d53f8dcf77d4" MODIFIED="1593745252660" TEXT="PRIMARY KEY"><node CREATED="1593745252660" ID="ID_d0b1d3e679bf" MODIFIED="1593745252660" TEXT="用于控制字段内容不能重复，一个表只允许出现一个"></node></node><node CREATED="1593745252660" ID="ID_8823e1bc63a2" MODIFIED="1593745252660" TEXT="FOREIGN KEY"><node CREATED="1593745252660" ID="ID_74069b521850" MODIFIED="1593745252660" TEXT="用于预防破环表之间连接的动作，也能防止非法数据插入外键列"></node></node><node CREATED="1593745252660" ID="ID_a58b849bc379" MODIFIED="1593745252660" TEXT="CHECK"><node CREATED="1593745252660" ID="ID_fd6487246a9b" MODIFIED="1593745252660" TEXT="用于控制字段的值范围"></node></node></node><node CREATED="1593745252660" ID="ID_96707f647e48" MODIFIED="1593745252660" TEXT="数据库优化的思路"><node CREATED="1593745252660" ID="ID_225242254704" MODIFIED="1593745252660" TEXT="选取最有效率的表名顺序"><node CREATED="1593745252660" ID="ID_414cabdac822" MODIFIED="1593745252660" TEXT="数据库的解析器按照从右到左的顺序处理FROM子句中的表名，FROM子句中写在最后的表将被最先处理"><node CREATED="1593745252660" ID="ID_6809d90fde08" MODIFIED="1593745252660" TEXT="如果三个表是完全 无关系的话，将记录和列名最少的表，写在最后，即选择记录条数最少的表放在最后"></node><node CREATED="1593745252660" ID="ID_114eaf81fa02" MODIFIED="1593745252660" TEXT="如果三个表是有关系的话，将引用最多的表，放在最后，即被其他表所引用的表放在最后"></node></node></node><node CREATED="1593745252660" ID="ID_59be16cb6bf6" MODIFIED="1593745252660" TEXT="WHERE子句中的连接顺序"><node CREATED="1593745252660" ID="ID_a3c7cf74641d" MODIFIED="1593745252660" TEXT="数据库采用自右向左的顺序解析WHERE子句，根据这个原理，表之间的连接必须写在其他WHERE条件之左，那些可以过滤掉最大数量记录的条件必须写在WHERE子句之右"></node></node><node CREATED="1593745252660" ID="ID_130ae6b94f33" MODIFIED="1593745252660" TEXT="SELECT子句中避免使用*号"><node CREATED="1593745252660" ID="ID_1304b6e452f4" MODIFIED="1593745252660" TEXT="*号可以获取表中全部的字段数据，但它是通过查询数据字典完成的，这意味着将耗费更多的时间"></node><node CREATED="1593745252660" ID="ID_6dfeb8d09423" MODIFIED="1593745252660" TEXT="使用*号写出来的SQL语句也不够直观"></node></node><node CREATED="1593745252660" ID="ID_6efcfcf29544" MODIFIED="1593745252660" TEXT="使用TRUNCATE替代DELETE"><node CREATED="1593745252660" ID="ID_c6126c079977" MODIFIED="1593745252660" TEXT="对于删除表的全部记录，DELETE是逐条删除，Truncate是将整个表删除"></node></node><node CREATED="1593745252660" ID="ID_e1203218ab90" MODIFIED="1593745252660" TEXT="多使用内部函数提高SQL效率"><node CREATED="1593745252660" ID="ID_199fa7f70efd" MODIFIED="1593745252660" TEXT="例如 ： 使用mysql的concat()函数会比使用||来进行拼接快，因为concat()函数已经被sql优化过了"></node></node><node CREATED="1593745252660" ID="ID_371a47dac0ec" MODIFIED="1593745252660" TEXT="使用表或列的别名"><node CREATED="1593745252660" ID="ID_eb0cbcdf9e63" MODIFIED="1593745252660" TEXT="一些简短的别名也能稍微提高一些SQL的性能"></node></node><node CREATED="1593745252660" ID="ID_5acf7c12fc2e" MODIFIED="1593745252660" TEXT="善用索引"><node CREATED="1593745252660" ID="ID_189ee45321c6" MODIFIED="1593745252660" TEXT="索引就是为了提高我们的查询数据的速度的，当表的记录量非常大时，我们就可以使用索引了"></node></node><node CREATED="1593745252660" ID="ID_e53d32189b93" MODIFIED="1593745252660" TEXT="SQL写大写"><node CREATED="1593745252660" ID="ID_83778d4932c8" MODIFIED="1593745252660" TEXT="Oracle服务器总是先将小写字母转成大写后，才执行"></node></node><node CREATED="1593745252660" ID="ID_2d84a349646f" MODIFIED="1593745252660" TEXT="避免在索引上使用NOT"><node CREATED="1593745252660" ID="ID_cf6380c375ed" MODIFIED="1593745252660" TEXT="Oracle服务器在遇到NOT后，他就会停止目前的工作，转而执行全表扫描"></node></node><node CREATED="1593745252660" ID="ID_badb2b2deb6a" MODIFIED="1593745252660" TEXT="避免在索引列上使用计算"><node CREATED="1593745252660" ID="ID_beeb00161b78" MODIFIED="1593745252660" TEXT="WHERE子句中，如果索引列是函数的一部分，优化器将不使用索引而使用全表扫描，这样会变慢"></node></node><node CREATED="1593745252660" ID="ID_a421f116c543" MODIFIED="1593745252660" TEXT="使用&amp;gt;=替代&amp;gt;"><node CREATED="1593745252660" ID="ID_4559e6c5a7fb" MODIFIED="1593745252660" TEXT="使用&amp;gt;会先定位到&amp;gt;的记录，然后扫描第一个大于的记录。&amp;gt;=会直接跳到第一个=的记录"></node></node><node CREATED="1593745252660" ID="ID_8f65e740ec8b" MODIFIED="1593745252660" TEXT="使用IN替代OR"><node CREATED="1593745252660" ID="ID_3b1d6f5ff94b" MODIFIED="1593745252660" TEXT="select * from emp where sal =100 or sal = 1000 or sal = 10;替换为 select * from emp where sal in (100,1000,10)"></node></node><node CREATED="1593745252660" ID="ID_ffcd79b2db20" MODIFIED="1593745252660" TEXT="总是使用索引的第一个列"><node CREATED="1593745252660" ID="ID_e54944e663ad" MODIFIED="1593745252660" TEXT="如果索引是建立在多个列上，只有在它的第一个列别WHERE子句引用时，优化器才会选择使用该索引"></node></node><node CREATED="1593745252660" ID="ID_8acb433ad360" MODIFIED="1593745252660" TEXT="优化答题"><node CREATED="1593745252660" ID="ID_78ca8fbccf98" MODIFIED="1593745252660" TEXT="先看慢日志，定位哪条语句慢，然后看语句的索引使用情况，是否使用到索引，索引是否失效。如果未建立索引，就建立索引。已经建立索引的话，就通过explain查看执行计划，通过type，key，rows，extra定位问题。type就是访问类型，ALL&amp;lt;index&amp;lt;range&amp;lt;ref&amp;lt;eq_ref。key就是具体使用的索引，rows是通过多少行拿到数据，extra常见Using filesort,出现在排序时索引失效，例如联合索引顺序有问题。extra还有Using temporary，使用临时表保存中间结果&amp;lt;br&amp;gt;"></node></node></node><node CREATED="1593745252660" ID="ID_40b3d895ff2a" MODIFIED="1593745252660" TEXT="SQL优化的一般步骤是什么，怎么查看执行计划"><node CREATED="1593745252660" ID="ID_3bc5a4096ef1" MODIFIED="1593745252660" TEXT="查看慢日志（show [session|gobal] status ），定位慢查询，查看慢查询执行计划 根据执行计划确认优化方案"></node></node><node CREATED="1593745252660" ID="ID_8d5fa7da94a3" MODIFIED="1593745252660" TEXT="MyISAM和InnoDB"><node CREATED="1593745252660" ID="ID_7fab87bf2bbf" MODIFIED="1593745252660" TEXT="区别"><node CREATED="1593745252660" ID="ID_878dc90d0907" MODIFIED="1593745252660" TEXT="count运算上的区别"><node CREATED="1593745252660" ID="ID_f7b5fcb5eb2f" MODIFIED="1593745252660" TEXT="因为MyISAM缓存有表meta-data（行数等），因此在做COUNT(*)时对于一个结构很好的查询是不需要消耗多少资源的。而对于InnoDB来说，则没有这种缓存"></node></node><node CREATED="1593745252660" ID="ID_3c5aa059913c" MODIFIED="1593745252660" TEXT="是否支持事务和崩溃后的安全恢复"><node CREATED="1593745252660" ID="ID_18ab5f0cb9fc" MODIFIED="1593745252660" TEXT="MyISAM 强调的是性能，每次查询具有原子性,其执行数度比InnoDB类型更快，但是不提供事务支持。但是InnoDB 提供事务支持事务，外部键等高级数据库功能。 具有事务(commit)、回滚(rollback)和崩溃修复能力(crash recovery capabilities)的事务安全(transaction-safe (ACID compliant))型表"></node></node><node CREATED="1593745252660" ID="ID_333ac0db58ad" MODIFIED="1593745252660" TEXT="是否支持外键"><node CREATED="1593745252660" ID="ID_24f0c71af301" MODIFIED="1593745252660" TEXT="MyISAM不支持，而InnoDB支持"></node></node></node><node CREATED="1593745252660" ID="ID_74081d7e7898" MODIFIED="1593745252660" TEXT="MyISAM更适合读密集的表，而InnoDB更适合写密集的的表。 在数据库做主从分离的情况下，经常选择MyISAM作为主库的存储引擎。&amp;lt;br&amp;gt;一般来说，如果需要事务支持，并且有较高的并发读取频率(MyISAM的表锁的粒度太大，所以当该表写并发量较高时，要等待的查询就会很多了)，InnoDB是不错的选择。如果你的数据量很大（MyISAM支持压缩特性可以减少磁盘的空间占用），而且不需要支持事务时，MyISAM是最好的选择"></node></node><node CREATED="1593745252660" ID="ID_d8c5b4842591" MODIFIED="1593745252660" TEXT="MVCC多版本并发控制"><node CREATED="1593745252660" ID="ID_7a17374d4dcf" MODIFIED="1593745252660" TEXT="通过保存数据在某个时间点的快照来实现的。MVCC主要作用于事务性的，有行锁控制的数据库模型"></node><node CREATED="1593745252660" ID="ID_f2d65422cb30" MODIFIED="1593745252660" TEXT="InnoDB存储引擎MVCC实现策略"><node CREATED="1593745252660" ID="ID_e0459a70067a" MODIFIED="1593745252660" TEXT="版本链"><node CREATED="1593745252660" ID="ID_b04a3fddf357" MODIFIED="1593745252660" TEXT="额外存储每次对某条聚簇索引记录进行修改的事务id和指向这条聚簇索引上一个版本的位置，上一版本的数据会保存在Undo日志中"></node></node><node CREATED="1593745252660" ID="ID_d094561b7253" MODIFIED="1593745252660" TEXT="ReadView"><node CREATED="1593745252660" ID="ID_395a1c71049f" MODIFIED="1593745252660" TEXT="ReadView中有个列表存储系统中未提交的事务，通过这个列表来判断记录的某个版本是否对当前事务可见"></node></node><node CREATED="1593745252660" ID="ID_e92149d56750" MODIFIED="1593745252660" TEXT="当进行查询时，如果该行数据的版本号在列表记录前，就可以访问，在列表记录中和后，就不能访问"></node></node></node><node CREATED="1593745252660" ID="ID_5450126ea8c3" MODIFIED="1593745252660" TEXT="explain"><node CREATED="1593745252660" ID="ID_41c7c72e0aae" MODIFIED="1593745252660" TEXT="通过explain命令可以知道：表的读取顺序、数据读取操作的类型、哪些索引可以使用、哪些索引实际使用了、表之间的引用、每张表有多少行被优化器查询等信息"></node></node><node CREATED="1593745252660" ID="ID_93e50f36fe64" MODIFIED="1593745252660" TEXT="经典面试题"><node CREATED="1593745252660" ID="ID_aebdbe09808b" MODIFIED="1593745252660" LINK="https://blog.csdn.net/waveclouds/article/details/79535685"></node></node></node><node CREATED="1593745252660" ID="ID_1756147f392d" POSITION="right" MODIFIED="1593745252660" TEXT="计算机网络"><node CREATED="1593745252660" ID="ID_bacfca1c40a4" MODIFIED="1593745252660" TEXT="五层协议的体系结构"><node CREATED="1593745252660" ID="ID_5e5a8b648967" MODIFIED="1593745252660" TEXT="物理层"></node><node CREATED="1593745252660" ID="ID_5d9e6acb1c0d" MODIFIED="1593745252660" TEXT="数据链路层"><node CREATED="1593745252660" ID="ID_ad188cc6900c" MODIFIED="1593745252660" TEXT="两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议"></node></node><node CREATED="1593745252660" ID="ID_db4faeeee1d2" MODIFIED="1593745252660" TEXT="网络层"><node CREATED="1593745252660" ID="ID_e8bf9d537033" MODIFIED="1593745252660" TEXT="网络层负责为分组交换网上的不同主机提供通信服务。在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送"></node></node><node CREATED="1593745252660" ID="ID_6577a404f0a6" MODIFIED="1593745252660" TEXT="运输层(transport layer)"><node CREATED="1593745252660" ID="ID_fb25fad11153" MODIFIED="1593745252660" TEXT="运输层的主要任务就是负责向两台主机进程之间的通信提供通用的数据传输服务。应用进程利用该服务传送应用层报文"></node><node CREATED="1593745252660" ID="ID_015fa6a4b915" MODIFIED="1593745252660" TEXT="传输层协议"><node CREATED="1593745252660" ID="ID_4c3ba67e8f1c" MODIFIED="1593745252660" TEXT="传输控制协议 TCP(Transmisson Control Protocol)"><node CREATED="1593745252660" ID="ID_71d643a7d765" MODIFIED="1593745252660" TEXT="提供面向连接的，可靠的数据传输服务"></node><node CREATED="1593745252660" ID="ID_896b2274f1e0" MODIFIED="1593745252660" TEXT="TCP的主要特点"><node CREATED="1593745252660" ID="ID_718a4e4c428b" MODIFIED="1593745252660" TEXT="TCP是面向连接的"></node><node CREATED="1593745252660" ID="ID_3c1ffaf944cc" MODIFIED="1593745252660" TEXT="每一条TCP连接只能有两个端点，每一条TCP连接只能是点对点的(一对一)"></node><node CREATED="1593745252660" ID="ID_141226962c36" MODIFIED="1593745252660" TEXT="TCP提供可靠支付的服务，通过TCP连接传送的数据，无差错、不丢失、不重复、并且按序到达"></node><node CREATED="1593745252660" ID="ID_fb08b4d15893" MODIFIED="1593745252660" TEXT="TCP提供全双工通信。TCP允许通信双方的应用进程在任何时候都能发送数据。TCP连接的两端都设有发送缓存和接收缓存，用来临时存放双方通信的数据"></node><node CREATED="1593745252660" ID="ID_9db50a10a504" MODIFIED="1593745252660" TEXT="面向字节流。TCP中的“流”（stream）指的是流入进程或从进程流出的字节序列。“面向字节流”的含义是：虽然应用程序和TCP的交互是一次一个数据块（大小不等），但TCP把应用程序交下来的数据仅仅看成是一连串的无结构的字节流。"></node></node></node><node CREATED="1593745252661" ID="ID_1e44fa5f55a2" MODIFIED="1593745252661" TEXT="用户数据协议 UDP(User Datagram Protocol)"><node CREATED="1593745252661" ID="ID_edf8e32c86b9" MODIFIED="1593745252661" TEXT="提供无连接的，尽最大努力的数据传输服务(不保证数据传输的可靠性)"></node><node CREATED="1593745252661" ID="ID_1573ade7dbea" MODIFIED="1593745252661" TEXT="UDP的主要特点"><node CREATED="1593745252661" ID="ID_69c94b5f0ab5" MODIFIED="1593745252661" TEXT="UDP是无连接的"></node><node CREATED="1593745252661" ID="ID_6c5bf78e2216" MODIFIED="1593745252661" TEXT="UDP使用尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的链接状态"></node><node CREATED="1593745252661" ID="ID_34982ea52db9" MODIFIED="1593745252661" TEXT="UDP是面向报文的"></node><node CREATED="1593745252661" ID="ID_6187fb24cc89" MODIFIED="1593745252661" TEXT="UDP没有阻塞控制，因此网络出现阻塞不会使源主机的发送速率降低(对实时应用很有用，如IP电话，实时视频会议等)"></node><node CREATED="1593745252661" ID="ID_a499f41f59ba" MODIFIED="1593745252661" TEXT="UDP支持一对一、一对多、多对一和多对多的交互通信"></node><node CREATED="1593745252661" ID="ID_d1fab5c19266" MODIFIED="1593745252661" TEXT="UDP的首部开销小，只有8个字节，比TCP的20个字节的首部要短"></node></node></node><node CREATED="1593745252661" ID="ID_84a1d7315799" MODIFIED="1593745252661" TEXT="为什么UDP有时比TCP更有优势"><node CREATED="1593745252661" ID="ID_c02a74a861a5" MODIFIED="1593745252661" TEXT="网速的提升给UDP的稳定性提供可靠网络保障，丢包率很低，如果使用应用层重传，能够确保传输的可靠性"></node><node CREATED="1593745252661" ID="ID_a51805ccd941" MODIFIED="1593745252661" TEXT="TCP为了实现网络通信的可靠性，使用了复杂的拥塞控制算法，建立了繁琐的握手过程"></node><node CREATED="1593745252661" ID="ID_12bc4c0f2e59" MODIFIED="1593745252661" TEXT="TCP一旦发生丢包，TCP会将后续的包缓存起来，等前面的包重传并接收后再继续发送，延时会越来越大；UDP采用自定义重传机制，能够把丢包产生的延迟降到最低"></node></node></node></node><node CREATED="1593745252661" ID="ID_07cc969e7312" MODIFIED="1593745252661" TEXT="应用层(application layer)"><node CREATED="1593745252661" ID="ID_cb5bd8856ccc" MODIFIED="1593745252661" TEXT="应用层的任务是通过应用进程间的交互来完成特定网络应用。应用层协议定义的是应用进程间的通信和交互的规则。对于不同的网络需要不同的应用层协议"></node><node CREATED="1593745252661" ID="ID_b05a61d86ba9" MODIFIED="1593745252661" TEXT="应用层协议"><node CREATED="1593745252661" ID="ID_baefce025912" MODIFIED="1593745252661" TEXT="域名系统DNS(Domain Name System)"><node CREATED="1593745252661" ID="ID_36f79b91d67b" MODIFIED="1593745252661" TEXT="域名系统是因特网的一项核心服务，它作为可以将域名和IP地址相互映射的一个分布式数据库，能够使人更方便的访问互联网"></node></node><node CREATED="1593745252661" ID="ID_e7b99b2166ab" MODIFIED="1593745252661" TEXT="超文本传输协议HTTP(HyperText Transfer Protocol)"><node CREATED="1593745252661" ID="ID_a2a9ef6c98c7" MODIFIED="1593745252661" TEXT="超文本传输协议是互联网上应用最为广泛的一种网络协议。所有的WWW文件都必须遵守这个标准"></node></node></node><node CREATED="1593745252661" ID="ID_c2f03555f04a" MODIFIED="1593745252661" TEXT="应用层交互的数据单元称为报文"></node></node></node><node CREATED="1593745252661" ID="ID_817a46ebad31" MODIFIED="1593745252661" TEXT="TCP/IP的体系结构"><node CREATED="1593745252661" ID="ID_df28fede338d" MODIFIED="1593745252661" TEXT="网络接口层"></node><node CREATED="1593745252661" ID="ID_40f977145eef" MODIFIED="1593745252661" TEXT="网际层 IP"></node><node CREATED="1593745252661" ID="ID_11bcd7c1ffcb" MODIFIED="1593745252661" TEXT="运输层 （TCP或UDP）"></node><node CREATED="1593745252661" ID="ID_0d70c7260e03" MODIFIED="1593745252661" TEXT="应用层（各种应用层协议，如TELNET，FTP，SMTP等）"></node></node><node CREATED="1593745252661" ID="ID_25008a6bc3bb" MODIFIED="1593745252661" TEXT="TCP三次握手和四次分手"><node CREATED="1593745252661" ID="ID_5c923c45fb64" MODIFIED="1593745252661" TEXT="三次握手"><node CREATED="1593745252661" ID="ID_a8dc316239c1" MODIFIED="1593745252661" TEXT="第一次：客户端发送带有SYN=1，seq=x,标志的数据包给服务端,客户端进入SYN_SEND状态"></node><node CREATED="1593745252661" ID="ID_0f9f2ec04370" MODIFIED="1593745252661" TEXT="第二次：服务端发送带有SYN=1，ACK=1，seq=y,ack=x+1,标志的数据包给客户端，服务端进入SYN_RCVD状态"></node><node CREATED="1593745252661" ID="ID_08f9fec35fc5" MODIFIED="1593745252661" TEXT="第三次：客户端发送带有ACK=1，ack=y+1,标志的数据包给服务端，客户端进入ESTABLISHED状态，服务端接收到这个包后，也进入ESTABLISHED状态"></node></node><node CREATED="1593745252661" ID="ID_4f72395f930f" MODIFIED="1593745252661" TEXT="四次分手"><node CREATED="1593745252661" ID="ID_770041406105" MODIFIED="1593745252661" TEXT="第一次：客户端发送一个FIN=1,seq=x，表示自己已经没有数据可以发送了，但是仍然可以接受数据,进入FIN_WAIT_1状态"></node><node CREATED="1593745252661" ID="ID_56d94159cea1" MODIFIED="1593745252661" TEXT="第二次：服务器发回ACK=1，ack=x+1，表明自己收到客户端关闭连接的请求，但还没准备好关闭，进入CLOST_WAIT状态，客户端收到这个确认包后，进入FIN+WAIT_2状态"></node><node CREATED="1593745252661" ID="ID_5c4c40f457eb" MODIFIED="1593745252661" TEXT="第三次：服务端发送 FIN=1,seq=y的报文，进入LAST_ACK状态，等待客户端的最后一个ACK"></node><node CREATED="1593745252661" ID="ID_7193b0115013" MODIFIED="1593745252661" TEXT="第四次：客户端接收到服务端的关闭请求，发回ACK=1，ack=y+1报文确认，进入TIME_WAIT状态，等待可能的重传ACK包，服务端接收到这个确认包后，关闭连接，进入CLOSED状态，客户端等待两个最大段生命周期，进入CLOSED状态"></node></node><node CREATED="1593745252661" ID="ID_5d792108c9e9" MODIFIED="1593745252661" TEXT="三次握手的原因"><node CREATED="1593745252661" ID="ID_456ba7c39252" MODIFIED="1593745252661" TEXT="第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接"></node></node><node CREATED="1593745252661" ID="ID_6560842db2ac" MODIFIED="1593745252661" TEXT="第三次握手失败怎么办"><node CREATED="1593745252661" ID="ID_f558d30aac3c" MODIFIED="1593745252661" TEXT="直接发送RTS报文段，进入CLOSED状态，这样做的目的是为了防止SYN泛洪攻击"></node></node><node CREATED="1593745252661" ID="ID_303cdcb8508d" MODIFIED="1593745252661" TEXT="四次挥手的原因"><node CREATED="1593745252661" ID="ID_d4628431da90" MODIFIED="1593745252661" TEXT="为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文"></node></node></node><node CREATED="1593745252661" ID="ID_53fd4800a76c" MODIFIED="1593745252661" TEXT="TCP报文首部"><node CREATED="1593745252661" ID="ID_4e8f8c07ace8" MODIFIED="1593745252661" TEXT="源端口和目的端口"><node CREATED="1593745252661" ID="ID_671b9d8113a8" MODIFIED="1593745252661" TEXT="各占2个字节，分别写入源端口和目的端口"></node></node><node CREATED="1593745252661" ID="ID_57ea820c251e" MODIFIED="1593745252661" TEXT="序号seq"><node CREATED="1593745252661" ID="ID_d1eadee78484" MODIFIED="1593745252661" TEXT="占4个字节，TCP连接中传送的字节流中的每个字节都按顺序编号"></node></node><node CREATED="1593745252661" ID="ID_bb86db716c04" MODIFIED="1593745252661" TEXT="确认号ack"><node CREATED="1593745252661" ID="ID_851f3d678eb4" MODIFIED="1593745252661" TEXT="占4个字节，是期望收到对方下一个报文的第一个数据字节的序号"></node></node><node CREATED="1593745252661" ID="ID_4d8c46e4ba7a" MODIFIED="1593745252661" TEXT="数据偏移"><node CREATED="1593745252661" ID="ID_57a294d195e1" MODIFIED="1593745252661" TEXT="占4位，它指出TCP报文的数据距离TCP报文段的起始处有多远"></node></node><node CREATED="1593745252661" ID="ID_64cdcd5a88e3" MODIFIED="1593745252661" TEXT="保留"><node CREATED="1593745252661" ID="ID_9d23d6e55811" MODIFIED="1593745252661" TEXT="占6位，保留今后使用"></node></node><node CREATED="1593745252661" ID="ID_c4520304d96a" MODIFIED="1593745252661" TEXT="紧急URG"><node CREATED="1593745252661" ID="ID_7893cf959ec5" MODIFIED="1593745252661" TEXT="当URG=1,表明紧急指针字段有效。告诉系统此报文段中有紧急数据"></node></node><node CREATED="1593745252661" ID="ID_f384ef8f5be9" MODIFIED="1593745252661" TEXT="确认ACK"><node CREATED="1593745252661" ID="ID_422a501ceb34" MODIFIED="1593745252661" TEXT="仅当ACK=1时，确认号字段才有效。TCP规定，在连接建立后所有报文的传输都必须把ACK置1"></node></node><node CREATED="1593745252661" ID="ID_ed8975df2da3" MODIFIED="1593745252661" TEXT="推送PSH"><node CREATED="1593745252661" ID="ID_f9319c364484" MODIFIED="1593745252661" TEXT="当两个应用进程进行交互式通信时，有时在一端的应用进程希望在键入一个命令后立即就能收到对方的响应，这时候就PSH=1"></node></node><node CREATED="1593745252661" ID="ID_42143c1cabc3" MODIFIED="1593745252661" TEXT="复位RST"><node CREATED="1593745252661" ID="ID_6458fcf16945" MODIFIED="1593745252661" TEXT="当RST=1，表明TCP连接中出现严重差错，必须释放连接，然后再重新建立连接"></node></node><node CREATED="1593745252661" ID="ID_d87bbe83cef1" MODIFIED="1593745252661" TEXT="同步SYN"><node CREATED="1593745252661" ID="ID_95d396459dba" MODIFIED="1593745252661" TEXT="在连接建立时用来同步序号。当SYN=1，ACK=0，表明是连接请求报文，若同意连接，则响应报文中应该使SYN=1,ACK=1"></node></node><node CREATED="1593745252661" ID="ID_17d640a7b348" MODIFIED="1593745252661" TEXT="终止FIN"><node CREATED="1593745252661" ID="ID_6f4963b59f10" MODIFIED="1593745252661" TEXT="用来释放连接。当FIN=1，表明此报文的发送方的数据已经发送完毕，并且要求释放"></node></node><node CREATED="1593745252661" ID="ID_7ba0501cb5ec" MODIFIED="1593745252661" TEXT="窗口"><node CREATED="1593745252661" ID="ID_7c7be2ef295c" MODIFIED="1593745252661" TEXT="占2个字节，指的是通知接收方，发送本报文你需要有多大的空间来接受"></node></node><node CREATED="1593745252661" ID="ID_e108015caed4" MODIFIED="1593745252661" TEXT="检验和"><node CREATED="1593745252661" ID="ID_a6109a320f54" MODIFIED="1593745252661" TEXT="占2个字节，校验首部和数据两部分"></node></node><node CREATED="1593745252661" ID="ID_7a3af54cf29c" MODIFIED="1593745252661" TEXT="紧急指针"><node CREATED="1593745252661" ID="ID_aa07cba2ec02" MODIFIED="1593745252661" TEXT="占2个字节，指出本报文段中的紧急数据的字节数"></node></node><node CREATED="1593745252661" ID="ID_e0b9f04a1882" MODIFIED="1593745252661" TEXT="选项"><node CREATED="1593745252661" ID="ID_1aeba0b02fc4" MODIFIED="1593745252661" TEXT="长度可变，定义一些其他的可选的参数"></node></node></node><node CREATED="1593745252661" ID="ID_1d828da538eb" MODIFIED="1593745252661" TEXT="IP数据报首部"><node CREATED="1593745252661" ID="ID_fe4b1cfb2c64" MODIFIED="1593745252661" TEXT="版本"><node CREATED="1593745252661" ID="ID_d20d31150819" MODIFIED="1593745252661" TEXT="IPV4 和 IPV6两个版本"></node></node><node CREATED="1593745252661" ID="ID_9aae5070677e" MODIFIED="1593745252661" TEXT="首部长度"></node><node CREATED="1593745252661" ID="ID_076810482711" MODIFIED="1593745252661" TEXT="区分服务"></node><node CREATED="1593745252661" ID="ID_e87d256eb7cb" MODIFIED="1593745252661" TEXT="总长度"><node CREATED="1593745252661" ID="ID_e2dc760f4c48" MODIFIED="1593745252661" TEXT="包括首部长度和数据部分长度"></node></node><node CREATED="1593745252661" ID="ID_77c869ac5b04" MODIFIED="1593745252661" TEXT="生存时间"><node CREATED="1593745252661" ID="ID_a9ce5ec3f35f" MODIFIED="1593745252661" TEXT="防止无法交付的数据报在互联网中不断兜圈子。以路由器跳数为单位，当TTL为0时就丢弃"></node></node><node CREATED="1593745252661" ID="ID_7ce0ca5a95cf" MODIFIED="1593745252661" TEXT="协议"><node CREATED="1593745252661" ID="ID_c824db97cca5" MODIFIED="1593745252661" TEXT="指出携带的数据应该上交给哪个协议进行处理"></node></node><node CREATED="1593745252661" ID="ID_53e6b24eb22d" MODIFIED="1593745252661" TEXT="首部检验和"><node CREATED="1593745252661" ID="ID_79b8ab85842d" MODIFIED="1593745252661" TEXT="因为数据报每经过一个路由器，都要重新计算检验和，因此检验和不包括数据部分可以减少计算的工作量"></node></node><node CREATED="1593745252661" ID="ID_302bb36e590c" MODIFIED="1593745252661" TEXT="源地址"></node><node CREATED="1593745252661" ID="ID_5d4b76d8fa92" MODIFIED="1593745252661" TEXT="目的地址"></node><node CREATED="1593745252661" ID="ID_76a90beeb024" MODIFIED="1593745252661" TEXT="标识"><node CREATED="1593745252661" ID="ID_025c51128fc2" MODIFIED="1593745252661" TEXT="在数据报长度过长而发生分片的情况下，相同数据报的分片具有相同的标识符"></node></node><node CREATED="1593745252661" ID="ID_2d0666c8a0c4" MODIFIED="1593745252661" TEXT="片偏移"><node CREATED="1593745252661" ID="ID_75c0e9c51129" MODIFIED="1593745252661" TEXT="和标识符一起，用于发生分片的情况。片偏移的单位为8字节"></node></node></node><node CREATED="1593745252661" ID="ID_428d92137805" MODIFIED="1593745252661" TEXT="TCP拥塞控制机制"><node CREATED="1593745252661" ID="ID_83cc55dd9fde" MODIFIED="1593745252661" TEXT="原因"><node CREATED="1593745252661" ID="ID_2f05cd27696b" MODIFIED="1593745252661" TEXT="我们知道TCP通过一个定时器（timer）采样了RTT并计算RTO，但是，如果网络上的延时突然增加，那么，TCP对这个事做出的应对只有重传数据，然而重传会导致网络的负担更重，于是会导致更大的延迟以及更多的丢包，这就导致了恶性循环，最终形成“网络风暴” —— TCP的拥塞控制机制就是用于应对这种情况&amp;nbsp;"></node></node><node CREATED="1593745252661" ID="ID_bdfcb4071fb3" MODIFIED="1593745252661" TEXT="在某段时间，若对网络中某一个资源的需求超过了该资源所能提供的可用部分，网络的性能就会变坏，就是拥塞"></node><node CREATED="1593745252661" ID="ID_e98995967025" MODIFIED="1593745252661" TEXT="拥塞窗口"><node CREATED="1593745252661" ID="ID_cdc7b7c07781" MODIFIED="1593745252661" TEXT="在发送数据时，将拥塞窗口的大小与接收端ack的窗口的大小作比较，取较小者作为发送数据量的上限"></node></node><node CREATED="1593745252661" ID="ID_67c8b44a517d" MODIFIED="1593745252661" TEXT="拥塞控制算法"><node CREATED="1593745252661" ID="ID_9eed7db2a2ee" MODIFIED="1593745252661" TEXT="慢启动"><node CREATED="1593745252661" ID="ID_942ffb816412" MODIFIED="1593745252661" TEXT="刚刚加入网络的连接，一点一点的提速，不要一上来就把路占满，指数上升"></node></node><node CREATED="1593745252661" ID="ID_c300d338f7c9" MODIFIED="1593745252661" TEXT="拥塞避免"><node CREATED="1593745252661" ID="ID_7fff8d4a4fc4" MODIFIED="1593745252661" TEXT="当拥塞窗口达到一个阈值时，窗口不再呈指数上升，而是以线性上升，避免增长过快导致网络拥塞"></node></node><node CREATED="1593745252661" ID="ID_10a971664158" MODIFIED="1593745252661" TEXT="快重传"><node CREATED="1593745252661" ID="ID_47f1f06282e0" MODIFIED="1593745252661" TEXT="接收方在收到一个失序的报文段后就立即发出重复确认，而不要等到自己发送数据时捎带确认。发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必等待设置的重传时间"></node></node><node CREATED="1593745252661" ID="ID_da1ca99e401f" MODIFIED="1593745252661" TEXT="快恢复"><node CREATED="1593745252661" ID="ID_f0e6b61cbea1" MODIFIED="1593745252661" TEXT="慢开始只在TCP连接建立时和网络出现超时时才使用"></node><node CREATED="1593745252661" ID="ID_f974319ab2b8" MODIFIED="1593745252661" TEXT="当发送方连续收到三个重复确认时，就执行“乘法减小”算法，吧门限减半，但是不执行慢开始算法"></node></node></node></node><node CREATED="1593745252661" ID="ID_d0fa5076b27f" MODIFIED="1593745252661" TEXT="拥塞控制与流量控制的区别"><node CREATED="1593745252661" ID="ID_4f6dc4993cbb" MODIFIED="1593745252661" TEXT="拥塞控制是防止过多的数据注入到网络中，可以使网络中的路由器或链路不致过载，是一个全局性的过程"></node><node CREATED="1593745252661" ID="ID_6743151d9c3d" MODIFIED="1593745252661" TEXT="流量控制是点对点通信量的控制，是一个端到端的问题，主要就是抑制发送端发送数据的速率，以便接收端来得及接收"></node></node><node CREATED="1593745252661" ID="ID_86fedd58f351" MODIFIED="1593745252661" TEXT="滑动窗口"><node CREATED="1593745252661" ID="ID_fcb84690d577" MODIFIED="1593745252661" TEXT="TCP滑动窗口技术通过动态改变窗口大小来调节两台主机间数据传输"></node></node><node CREATED="1593745252661" ID="ID_11bda1d22a4a" MODIFIED="1593745252661" TEXT="状态码"><node CREATED="1593745252661" ID="ID_784e695bfc3f" MODIFIED="1593745252661" TEXT="1XX"><node CREATED="1593745252661" ID="ID_16e4fbc40039" MODIFIED="1593745252661" TEXT="信息性状态码"><node CREATED="1593745252661" ID="ID_951e8f02144e" MODIFIED="1593745252661" TEXT="接收的请求正在处理"></node></node></node><node CREATED="1593745252661" ID="ID_e9eb8e573b32" MODIFIED="1593745252661" TEXT="2XX"><node CREATED="1593745252661" ID="ID_aa8d930d0d84" MODIFIED="1593745252661" TEXT="成功状态码"><node CREATED="1593745252661" ID="ID_a20bbd4dc057" MODIFIED="1593745252661" TEXT="请求正常处理完毕"></node></node></node><node CREATED="1593745252661" ID="ID_fcdd50e0a893" MODIFIED="1593745252661" TEXT="3XX"><node CREATED="1593745252661" ID="ID_7ec34338db48" MODIFIED="1593745252661" TEXT="重定向状态码"><node CREATED="1593745252661" ID="ID_fbaf0c48db9b" MODIFIED="1593745252661" TEXT="需要进行附加操作以完成请求"></node></node><node CREATED="1593745252661" ID="ID_79ca3339ccf1" MODIFIED="1593745252661" TEXT="301 永久性重定向"></node><node CREATED="1593745252661" ID="ID_261164bdbba0" MODIFIED="1593745252661" TEXT="302 零时性重定向"></node></node><node CREATED="1593745252661" ID="ID_be3778bb29ff" MODIFIED="1593745252661" TEXT="4XX"><node CREATED="1593745252661" ID="ID_69e8f0d7c7f4" MODIFIED="1593745252661" TEXT="客户端错误状态码"><node CREATED="1593745252661" ID="ID_41b2e6d3a907" MODIFIED="1593745252661" TEXT="服务器无法处理请求"></node></node><node CREATED="1593745252661" ID="ID_1c4e4c62975d" MODIFIED="1593745252661" TEXT="400 请求报文中存在语法错误"></node><node CREATED="1593745252661" ID="ID_4070856527b1" MODIFIED="1593745252661" TEXT="401 发送的请求需要有认证信息，若果之前已经进行过一次请求则标识用户认证失败"></node><node CREATED="1593745252661" ID="ID_4490ed9f698f" MODIFIED="1593745252661" TEXT="403 请求被拒绝"></node></node><node CREATED="1593745252661" ID="ID_540cd20ecedf" MODIFIED="1593745252661" TEXT="5XX"><node CREATED="1593745252661" ID="ID_5623b4325916" MODIFIED="1593745252661" TEXT="服务器错误状态码"><node CREATED="1593745252661" ID="ID_8d07d979b0fa" MODIFIED="1593745252661" TEXT="服务器处理请求出错"></node></node></node></node><node CREATED="1593745252661" ID="ID_1d83fde9577b" MODIFIED="1593745252661" TEXT="session和cookie"><node CREATED="1593745252661" ID="ID_7ee2d65cb1bf" MODIFIED="1593745252661" TEXT="cookie"><node CREATED="1593745252661" ID="ID_cede6fa74026" MODIFIED="1593745252661" TEXT="cookie是由服务器发送给客户端的小量信息，以{key:value}的形式存在"></node><node CREATED="1593745252661" ID="ID_777792257743" MODIFIED="1593745252661" TEXT="原理"><node CREATED="1593745252661" ID="ID_bac46e2bee44" MODIFIED="1593745252661" TEXT="客户端请求服务器时，如果服务器需要记录该用户状态，就使用response向客户端浏览器颁发一个Cookie。而客户端浏览器会把Cookie保存起来。当浏览器再请求 服务器时，浏览器把请求的网址连同该Cookie一同提交给服务器。服务器通过检查该Cookie来获取用户状态&amp;lt;br&amp;gt;"></node></node><node CREATED="1593745252661" ID="ID_acab2973a3c1" MODIFIED="1593745252661" TEXT="分类"><node CREATED="1593745252661" ID="ID_987246dfe582" MODIFIED="1593745252661" TEXT="会话期cookie"><node CREATED="1593745252661" ID="ID_4b5af978057b" MODIFIED="1593745252661" TEXT="浏览器关闭之后会被自动删除，也就是仅在会话期内有效"></node></node><node CREATED="1593745252661" ID="ID_288b761cb373" MODIFIED="1593745252661" TEXT="持久性cookie"><node CREATED="1593745252661" ID="ID_1f4b55d389d6" MODIFIED="1593745252661" TEXT="指定一个特定的过期时间或有效期之后就成为了持久性的cookie"></node></node></node></node><node CREATED="1593745252661" ID="ID_a747d43f242a" MODIFIED="1593745252661" TEXT="session"><node CREATED="1593745252661" ID="ID_be33b5ee2fdb" MODIFIED="1593745252661" TEXT="session以服务端保存状态"></node><node CREATED="1593745252661" ID="ID_2681a833bb45" MODIFIED="1593745252661" TEXT="原理"><node CREATED="1593745252661" ID="ID_eb7c1fc895b9" MODIFIED="1593745252661" TEXT="当客户端请求,服务端创建一个session，生成sessionID"></node><node CREATED="1593745252661" ID="ID_e6deaba1e97d" MODIFIED="1593745252661" TEXT="服务端返回的响应报文的set-cookie首部字段包含这个sessionID，客户端将该Cookie值存入浏览器中"></node><node CREATED="1593745252661" ID="ID_1ca82656e01b" MODIFIED="1593745252661" TEXT="客户端再次请求时会包含该cookie，服务器收到之后提取出sessionID，取出用户信息"></node></node></node><node CREATED="1593745252661" ID="ID_ebe61f506f3d" MODIFIED="1593745252661" TEXT="使用区别"><node CREATED="1593745252661" ID="ID_6aa52650ae11" MODIFIED="1593745252661" TEXT="登录信息等重要信息保存在session里"></node><node CREATED="1593745252661" ID="ID_ff066978e45c" MODIFIED="1593745252661" TEXT="其他信息保存在cookie里"></node></node></node><node CREATED="1593745252661" ID="ID_f0400132e44e" MODIFIED="1593745252661" TEXT="GET和POST的区别"><node CREATED="1593745252661" ID="ID_24984661eaef" MODIFIED="1593745252661" TEXT="对于RESTful规范来说，get用来获取数据，post用来提交数据"></node><node CREATED="1593745252661" ID="ID_c86cd59bef85" MODIFIED="1593745252661" TEXT="get是幂等的，post是非幂等的"></node><node CREATED="1593745252661" ID="ID_9c6cdf85f47f" MODIFIED="1593745252661" TEXT="post更安全，不会被缓存、保存在服务器日志以及浏览器记录中"></node><node CREATED="1593745252661" ID="ID_be03c0bd2018" MODIFIED="1593745252661" TEXT="get要快于post"></node></node><node CREATED="1593745252661" ID="ID_b2382bff6e06" MODIFIED="1593745252661" TEXT="HTTP1.0和2.0的区别"><node CREATED="1593745252661" ID="ID_c86baf22fe6e" MODIFIED="1593745252661" TEXT="HTTP1.1"><node CREATED="1593745252661" ID="ID_18c3a8f64034" MODIFIED="1593745252661" TEXT="缓存处理"><node CREATED="1593745252661" ID="ID_fd15946689c9" MODIFIED="1593745252661" TEXT="header里引入更多可供选择的缓存头来控制缓存策略"></node></node><node CREATED="1593745252661" ID="ID_9a91fa8a4095" MODIFIED="1593745252661" TEXT="带宽优化及网络连接的使用"><node CREATED="1593745252661" ID="ID_80243bbc1023" MODIFIED="1593745252661" TEXT="断点续传，请求头引入range头域，允许只请求资源的某个部分"></node></node><node CREATED="1593745252661" ID="ID_6494b6c07529" MODIFIED="1593745252661" TEXT="错误通知的管理"><node CREATED="1593745252661" ID="ID_9c83e52e3788" MODIFIED="1593745252661" TEXT="新增24个错误状态响应码"></node></node><node CREATED="1593745252661" ID="ID_809a69e76119" MODIFIED="1593745252661" TEXT="Host头处理"><node CREATED="1593745252661" ID="ID_9009ee35cf7a" MODIFIED="1593745252661" TEXT="支持虚拟主机"></node></node><node CREATED="1593745252661" ID="ID_f642c77e8b0f" MODIFIED="1593745252661" TEXT="长连接"></node></node><node CREATED="1593745252661" ID="ID_cd69048c6014" MODIFIED="1593745252661" TEXT="HTTP2.0"><node CREATED="1593745252661" ID="ID_3c55ca90a0d0" MODIFIED="1593745252661" TEXT="新的二进制格式"><node CREATED="1593745252661" ID="ID_da30731a23f3" MODIFIED="1593745252661" TEXT="HTTP1.X解析是基于文本，HTTP2.0的协议解析采用二进制格式，方便且健壮"></node></node><node CREATED="1593745252661" ID="ID_f045cb138f06" MODIFIED="1593745252661" TEXT="多路复用"><node CREATED="1593745252661" ID="ID_b6a1b7c04e52" MODIFIED="1593745252661" TEXT="连接共享，一个request对应一个id，一个连接上可以有多个request，每个连接的request可以随机的混杂在一起"></node></node><node CREATED="1593745252661" ID="ID_46f98b654d85" MODIFIED="1593745252661" TEXT="header压缩"><node CREATED="1593745252661" ID="ID_89f7fe92fe38" MODIFIED="1593745252661" TEXT="通讯双方各自cache一份header fields，避免重复header的传输，HTTP2.0 也使用哈夫曼编码对首部字段进行压缩"></node></node><node CREATED="1593745252661" ID="ID_3dbd0195c7e4" MODIFIED="1593745252661" TEXT="服务端推送"><node CREATED="1593745252661" ID="ID_01f7dc403b27" MODIFIED="1593745252661" TEXT="浏览器请求index.html，服务器把相应的style.css，example.png全部发送给浏览器，减少HTTP通信轮数"></node></node></node></node><node CREATED="1593745252661" ID="ID_b90ccda5ae13" MODIFIED="1593745252661" TEXT="转发与重定向区别"><node CREATED="1593745252661" ID="ID_828a4b117e2d" MODIFIED="1593745252661" TEXT="转发在服务器端完成，重定向在客户端完成"></node><node CREATED="1593745252661" ID="ID_b97604a67d37" MODIFIED="1593745252661" TEXT="转发速度快，重定速度慢"></node><node CREATED="1593745252661" ID="ID_52075ac6a3f6" MODIFIED="1593745252661" TEXT="转发的是同一次请求，重定向是两次不同请求"></node><node CREATED="1593745252661" ID="ID_7af80aff8807" MODIFIED="1593745252661" TEXT="转发地址栏没有变化，重定向地址栏有变化"></node></node><node CREATED="1593745252661" ID="ID_0e2337a7cf63" MODIFIED="1593745252661" TEXT="TCP和UDP的特点"><node CREATED="1593745252661" ID="ID_073e62ffb406" MODIFIED="1593745252661" TEXT="UDP是无连接的，尽最大可能交付，没有拥塞控制，面向报文，支持一对一，一对多，多对一，多对多的交互通信"></node><node CREATED="1593745252661" ID="ID_900bb29f10d2" MODIFIED="1593745252661" TEXT="TCP是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流，每一条TCP连接只能是一对一的"></node><node CREATED="1593745252661" ID="ID_3d1468377d6f" MODIFIED="1593745252661" TEXT="TCP和UDP的区别"><node CREATED="1593745252661" ID="ID_04b0a5c634e6" MODIFIED="1593745252661" TEXT="TCP是面向连接的，UDP是无连接的"></node><node CREATED="1593745252661" ID="ID_6ef710031aeb" MODIFIED="1593745252661" TEXT="TCP提供可靠的服务，即通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达；UDP尽最大努力交付，即不保证可靠交付"></node><node CREATED="1593745252661" ID="ID_a4c522d5bca1" MODIFIED="1593745252661" TEXT="UDP具有较好的实时性，工作效率比TCP高，适用于高速传输和对实时性有较高的要求的通信或广播通信"></node><node CREATED="1593745252662" ID="ID_0aeec97821f9" MODIFIED="1593745252662" TEXT="每一条TCP连接只能是点到点的，UDP支持一对一，一对多，多对一，多对多的交互通信"></node><node CREATED="1593745252662" ID="ID_babaf3f14e35" MODIFIED="1593745252662" TEXT="TCP对系统资源要求较多，UDP对系统资源要求较少"></node></node></node><node CREATED="1593745252662" ID="ID_7c7c82b1b26e" MODIFIED="1593745252662" TEXT="使用代理服务器的原因"><node CREATED="1593745252662" ID="ID_b2daab8f7b35" MODIFIED="1593745252662" TEXT="缓存"><node CREATED="1593745252662" ID="ID_0529fa1bfeaa" MODIFIED="1593745252662" TEXT="缓存一些公有资源"></node></node><node CREATED="1593745252662" ID="ID_2568060a3f54" MODIFIED="1593745252662" TEXT="负载均衡"></node><node CREATED="1593745252662" ID="ID_813729da3ad3" MODIFIED="1593745252662" TEXT="网络访问控制"></node><node CREATED="1593745252662" ID="ID_1887483f0431" MODIFIED="1593745252662" TEXT="访问日志记录"></node></node><node CREATED="1593745252662" ID="ID_7fbdf75b2467" MODIFIED="1593745252662" TEXT="HTTPS"><node CREATED="1593745252662" ID="ID_c7da34cd31f2" MODIFIED="1593745252662" TEXT="HTTP + 加密 + 身份认证 + 完整性保护"></node></node><node CREATED="1593745252662" ID="ID_ebb13025f2f2" MODIFIED="1593745252662" TEXT="DNS"><node CREATED="1593745252662" ID="ID_46ff5b5fad70" MODIFIED="1593745252662" TEXT="浏览器根据访问的域名找到其IP地址"></node><node CREATED="1593745252662" ID="ID_c1eb3c111199" MODIFIED="1593745252662" TEXT="DNS查找过程"><node CREATED="1593745252662" ID="ID_cbba8b5426a7" MODIFIED="1593745252662" TEXT="浏览器缓存：浏览器会缓存DNS记录一段时间"></node><node CREATED="1593745252662" ID="ID_7b4294dceeda" MODIFIED="1593745252662" TEXT="系统缓存：浏览器会做一个系统调用，这样便可获得系统缓存中的记录"></node><node CREATED="1593745252662" ID="ID_fd4038b5be39" MODIFIED="1593745252662" TEXT="路由器缓存"><node CREATED="1593745252662" ID="ID_f83aaeb214e9" MODIFIED="1593745252662" TEXT="向路由器发送查询请求，路由器一般会有自己的DNS缓存"></node></node><node CREATED="1593745252662" ID="ID_5dbae52189f8" MODIFIED="1593745252662" TEXT="ISP DNS缓存"><node CREATED="1593745252662" ID="ID_1195bd7ec11f" MODIFIED="1593745252662" TEXT="请求缓存DNS的服务器"></node></node></node></node><node CREATED="1593745252662" ID="ID_eb0c7667c672" MODIFIED="1593745252662" TEXT="一个网页从开始请求到最终显示的完整过程"><node CREATED="1593745252662" ID="ID_bc64e3551866" MODIFIED="1593745252662" TEXT="在浏览器中输入网址"></node><node CREATED="1593745252662" ID="ID_ef45bce4a7eb" MODIFIED="1593745252662" TEXT="发送至DNS服务器并获得域名对应的WEB服务器的IP地址"></node><node CREATED="1593745252662" ID="ID_f7afcf2e7b58" MODIFIED="1593745252662" TEXT="与WEB服务器通过三次握手建立TCP连接"></node><node CREATED="1593745252662" ID="ID_a67a8151bdb5" MODIFIED="1593745252662" TEXT="浏览器向WEB服务器的IP地址发送相应的HTTP请求"></node><node CREATED="1593745252662" ID="ID_ae9ab677169b" MODIFIED="1593745252662" TEXT="WEB服务器响应请求并返回指定URL的数据，或错误信息，如果设定重定向，则重定向到新的URL地址"></node><node CREATED="1593745252662" ID="ID_6ad573b85b5f" MODIFIED="1593745252662" TEXT="浏览器下载数据后解析HTML源文件，解析的过程中实现对页面的排版，解析完成后再浏览器中显示基础页面"></node><node CREATED="1593745252662" ID="ID_073522ca2909" MODIFIED="1593745252662" TEXT="分析页面中的超链接并显示在当前页面，重复以上过程直至无超链接需要发送，完成全部显示"></node></node></node><node CREATED="1593745252662" ID="ID_5c156dbe5527" POSITION="right" MODIFIED="1593745252662" TEXT="操作系统"><node CREATED="1593745252662" ID="ID_2760547bc9a4" MODIFIED="1593745252662" TEXT="多线程"><node CREATED="1593745252662" ID="ID_91bab3278ae9" MODIFIED="1593745252662" TEXT="synchronized"><node CREATED="1593745252662" ID="ID_9fa09cf0473e" MODIFIED="1593745252662" TEXT="synchronized关键字解决的是多个线程之间访问资源的同步性，synchronized关键字可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行"></node><node CREATED="1593745252662" ID="ID_678b8592675d" MODIFIED="1593745252662" TEXT="synchronized使用方式"><node CREATED="1593745252662" ID="ID_c461f7aa7ac1" MODIFIED="1593745252662" TEXT="修饰实例方法"><node CREATED="1593745252662" ID="ID_5d6ed5b4eed8" MODIFIED="1593745252662" TEXT="被修饰的方法称为同步方法，作用的范围是整个方法，作用的对象是调用这个方法的对象"></node></node><node CREATED="1593745252662" ID="ID_75d0808317b5" MODIFIED="1593745252662" TEXT="修饰静态方法"><node CREATED="1593745252662" ID="ID_10e747679f6a" MODIFIED="1593745252662" TEXT="作用的范围是整个静态方法，作用的对象是这个类的所有对象"></node></node><node CREATED="1593745252662" ID="ID_f986eca7885b" MODIFIED="1593745252662" TEXT="修饰代码块"><node CREATED="1593745252662" ID="ID_c04c486f9662" MODIFIED="1593745252662" TEXT="被修饰的代码块称为同步代码块，作用的范围是大括号{}内的代码，作用的对象是调用这个代码块的对象"></node></node><node CREATED="1593745252662" ID="ID_393e757f4397" MODIFIED="1593745252662" TEXT="修饰类"><node CREATED="1593745252662" ID="ID_65fdbf70c9f0" MODIFIED="1593745252662" TEXT="作用的范围是synchronized后面括号括起来的部分，作用的对象是这个类的所有对象"></node></node><node CREATED="1593745252662" ID="ID_0a067ac13206" MODIFIED="1593745252662" TEXT="sychronized修饰不加static的方法，锁是加在单个对象上，不同的对象没有竞争关系；修饰加了static的方法，锁是加在类上，这个类所有的对象竞争一把锁"></node></node><node CREATED="1593745252662" ID="ID_de74b05942e0" MODIFIED="1593745252662" TEXT="sychronized缺陷"><node CREATED="1593745252662" ID="ID_e930d2130d13" MODIFIED="1593745252662" TEXT="获取锁的线程由于等待IO或者sleep等被阻塞了，但是没有释放锁，影响其他线程执行"></node><node CREATED="1593745252662" ID="ID_adfe72bdf6a2" MODIFIED="1593745252662" TEXT="当一个线程在进行读操作时，其他线程只能等待无法进行读操作"></node></node></node><node CREATED="1593745252662" ID="ID_90ad2e46e62a" MODIFIED="1593745252662" TEXT="volatile"><node CREATED="1593745252662" ID="ID_b8a4cbfc86af" MODIFIED="1593745252662" TEXT="作用"><node CREATED="1593745252662" ID="ID_a6f26bf68606" MODIFIED="1593745252662" TEXT="保证变量的可见性"></node><node CREATED="1593745252662" ID="ID_69cf2b895111" MODIFIED="1593745252662" TEXT="防止指令重排序"></node></node><node CREATED="1593745252662" ID="ID_8c758e578557" MODIFIED="1593745252662" TEXT="详解"><node CREATED="1593745252662" ID="ID_ab15dad7eaa9" MODIFIED="1593745252662" LINK="https://www.cnblogs.com/dolphin0520/p/3920373.html"></node><node CREATED="1593745252662" ID="ID_35345242d8b2" MODIFIED="1593745252662" TEXT="volatile的原理和实现机制"><node CREATED="1593745252662" ID="ID_eb1101ef6a7d" MODIFIED="1593745252662" TEXT="观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令"></node><node CREATED="1593745252662" ID="ID_17710f7ed870" MODIFIED="1593745252662" TEXT="lock前缀指令实际上相当于一个内存屏障"><node CREATED="1593745252662" ID="ID_2eedede2b1f7" MODIFIED="1593745252662" TEXT="它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成"></node><node CREATED="1593745252662" ID="ID_1d6cfb53f66a" MODIFIED="1593745252662" TEXT="它会强制将对缓存的修改操作立即写入主存"></node><node CREATED="1593745252662" ID="ID_8edfe4da6ce4" MODIFIED="1593745252662" TEXT="如果是写操作，它会导致其他CPU中对应的缓存行无效"></node></node></node></node></node><node CREATED="1593745252662" ID="ID_1f586f4b8043" MODIFIED="1593745252662" TEXT="synchronized关键字与volatile关键字的区别"><node CREATED="1593745252662" ID="ID_01ac6a4442c2" MODIFIED="1593745252662" TEXT="volatile关键字是线程同步的轻量级实现，所以性能比synchronized关键字要好"></node><node CREATED="1593745252662" ID="ID_aa5587999dac" MODIFIED="1593745252662" TEXT="volatile关键字只能用于变量而synchronized关键字可以修饰方法以及代码块"></node><node CREATED="1593745252662" ID="ID_ee99ac14ccf1" MODIFIED="1593745252662" TEXT="多线程访问volatile关键字不会发生阻塞，而synchronized关键字可能会发生阻塞"></node><node CREATED="1593745252662" ID="ID_3c88fb69672b" MODIFIED="1593745252662" TEXT="volatile关键字能保证数据的可见性，但不能保证数据的原子性。synchronized关键字两者都能保证"></node><node CREATED="1593745252662" ID="ID_a5d39c7cbeac" MODIFIED="1593745252662" TEXT="volatile关键字主要用于解决变量在多个线程之间的可见性，而synchronized关键字解决的是多个线程之间访问资源的同步性"></node></node><node CREATED="1593745252662" ID="ID_b7b619fd2617" MODIFIED="1593745252662" TEXT="synchronized与Lock的区别"><node CREATED="1593745252662" ID="ID_125537287f3c" MODIFIED="1593745252662" TEXT="两者都是可重入锁"><node CREATED="1593745252662" ID="ID_12a0cee36c44" MODIFIED="1593745252662" TEXT="可重入锁指自己可以再次获取自己的内部锁"></node></node><node CREATED="1593745252662" ID="ID_c39890581bdd" MODIFIED="1593745252662" TEXT="synchronized依赖于JVM，reenTrantLock依赖于API"></node><node CREATED="1593745252662" ID="ID_0b2f4fb16e0e" MODIFIED="1593745252662" TEXT="reenTrantLock比synchronized增加了一些高级功能"><node CREATED="1593745252662" ID="ID_ffd3b7193238" MODIFIED="1593745252662" TEXT="新功能"><node CREATED="1593745252662" ID="ID_46257b1528cc" MODIFIED="1593745252662" TEXT="等待可中断"><node CREATED="1593745252662" ID="ID_2f9964cb476a" MODIFIED="1593745252662" TEXT="ReenTrantLock可以通过 lock.lockInterruptibly()将正在等待的线程放弃，转而处理其他事情"></node></node><node CREATED="1593745252662" ID="ID_d5d5920e09e5" MODIFIED="1593745252662" TEXT="可实现公平锁"><node CREATED="1593745252662" ID="ID_72a85c242930" MODIFIED="1593745252662" TEXT="synchronized只能是非公平锁"></node><node CREATED="1593745252662" ID="ID_9c05d30e088f" MODIFIED="1593745252662" TEXT="ReenTrantLock默认是非公平的，可以通过 ReenTrantLock(boolean fair) 构造方法来指定是否是公平的"></node></node><node CREATED="1593745252662" ID="ID_5046a8b45fd7" MODIFIED="1593745252662" TEXT="可实现选择性通知(锁可以绑定多个条件)"><node CREATED="1593745252662" ID="ID_e45be6281545" MODIFIED="1593745252662" TEXT="synchronized关键字与 wait()和notify/notifyAll()方法结合可以实现等待/通知机制，但执行notifyAll()方法会通知所有处于等待状态的线程，从而造成很大的效率问题"></node><node CREATED="1593745252662" ID="ID_8dbd7f4203f9" MODIFIED="1593745252662" TEXT="ReenTrantLock借助于Condition接口和newCondition()方法，线程对象可以注册在指定的Condition中，从而可以有选择性的进行线程通知，在调度线程上更加灵活"></node></node></node></node><node CREATED="1593745252662" ID="ID_6887dcb9819a" MODIFIED="1593745252662" TEXT="synchronized不需要用户手动释放锁，系统会把执行完的synchronized方法或者代码块的锁释放，而lock则必须用户手动释放锁"></node></node><node CREATED="1593745252662" ID="ID_08c54bbaad84" MODIFIED="1593745252662" TEXT="实现Runnable接口和Callable接口的区别"><node CREATED="1593745252662" ID="ID_845cc35d1adf" MODIFIED="1593745252662" TEXT="Callable规定的方法是call()，Runnable规定的方法是run()"></node><node CREATED="1593745252662" ID="ID_e565a2e41b99" MODIFIED="1593745252662" TEXT="Runnable接口不会返回结果但是Callable接口可以返回结果"></node><node CREATED="1593745252662" ID="ID_06654380aa56" MODIFIED="1593745252662" TEXT="call()方法可抛出异常，run()方法不能抛出异常"></node></node><node CREATED="1593745252662" ID="ID_9d4f655ad677" MODIFIED="1593745252662" TEXT="执行execute()方法和submit()方法的区别"><node CREATED="1593745252662" ID="ID_a9c5e541163f" MODIFIED="1593745252662" TEXT="execute()方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否"></node><node CREATED="1593745252662" ID="ID_1220999bac4e" MODIFIED="1593745252662" TEXT="submit()用于提交需要返回值的任务，线程池会返回一个future类型的对象，通过这个future对象可以判断任务是否执行成功，并且可以通过future的get()方法来获取返回值，get()方法会阻塞当前线程直到任务完成，而使用get(long timeout, TimeUnit unit)方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完"></node></node><node CREATED="1593745252662" ID="ID_a2175f9ec978" MODIFIED="1593745252662" TEXT="线程池"><node CREATED="1593745252662" ID="ID_a8d3b6e579ac" MODIFIED="1593745252662" TEXT="线程池提供了一种限制和管理资源。每个线程池还维护一些基本信息，例如已完成任务的数量"></node><node CREATED="1593745252662" ID="ID_5449fb67ab2d" MODIFIED="1593745252662" TEXT="线程池的好处"><node CREATED="1593745252662" ID="ID_f3491a11aa7b" MODIFIED="1593745252662" TEXT="降低资源消耗"><node CREATED="1593745252662" ID="ID_e2d3d65820d9" MODIFIED="1593745252662" TEXT="通过重复利用已创建的线程降低线程创建和销毁造成的消耗"></node></node><node CREATED="1593745252662" ID="ID_d3c3c2cfdda8" MODIFIED="1593745252662" TEXT="提高响应速度"><node CREATED="1593745252662" ID="ID_4e05d118a286" MODIFIED="1593745252662" TEXT="当任务到达时，任务可以不需要等到线程创建就能立即执行"></node></node><node CREATED="1593745252662" ID="ID_c7e01d2ec104" MODIFIED="1593745252662" TEXT="提高线程的可管理性"><node CREATED="1593745252662" ID="ID_996e91ca144d" MODIFIED="1593745252662" TEXT="线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控"></node></node></node><node CREATED="1593745252662" ID="ID_448422150dc5" MODIFIED="1593745252662" TEXT="如何创建线程池"><node CREATED="1593745252662" ID="ID_ac3b140487f9" MODIFIED="1593745252662" TEXT="ThreadPoolExecutor类的四个构造方法"><node CREATED="1593745252662" ID="ID_2ab089a0ba34" MODIFIED="1593745252662" TEXT="newCachedThreadPool"><node CREATED="1593745252662" ID="ID_6e0c10d42bbb" MODIFIED="1593745252662" TEXT="创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程"></node></node><node CREATED="1593745252662" ID="ID_2a653a6c2e52" MODIFIED="1593745252662" TEXT="newFixedThreadPool"><node CREATED="1593745252662" ID="ID_a98747ccfa71" MODIFIED="1593745252662" TEXT="创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待"></node></node><node CREATED="1593745252662" ID="ID_5ae0a6da0860" MODIFIED="1593745252662" TEXT="newScheduledThreadPool"><node CREATED="1593745252662" ID="ID_29e3564c5c9f" MODIFIED="1593745252662" TEXT="创建一个定长线程池，支持定时及周期性任务执行"></node></node><node CREATED="1593745252662" ID="ID_4a8c84105488" MODIFIED="1593745252662" TEXT="newSingleThreadPool"><node CREATED="1593745252662" ID="ID_40e2e126f2f9" MODIFIED="1593745252662" TEXT="创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行"></node></node><node CREATED="1593745252662" ID="ID_a5b9bfe7edea" MODIFIED="1593745252662" TEXT="弊端"><node CREATED="1593745252662" ID="ID_627fce938057" MODIFIED="1593745252662" TEXT="newFixed 和newSingle 堆积的请求处理队列可能会耗费非常大的内存"></node><node CREATED="1593745252662" ID="ID_30de3b2a6fbb" MODIFIED="1593745252662" TEXT="newCached和newScheduled 线程数最大数是 Integer.MAX_VALUE 可能创建数量非常多的线程"></node></node></node><node CREATED="1593745252662" ID="ID_c17c36ac892e" MODIFIED="1593745252662" TEXT="线程池的参数"><node CREATED="1593745252662" ID="ID_47700a4dd8bd" MODIFIED="1593745252662" TEXT="corePoolSize 线程池核心线程数量"></node><node CREATED="1593745252662" ID="ID_09f2c7566575" MODIFIED="1593745252662" TEXT="maximumPoolSize 线程池最大线程数量"></node><node CREATED="1593745252662" ID="ID_db2557f1fe82" MODIFIED="1593745252662" TEXT="keepAliverTime 当活跃线程数大于核心线程数时，空闲的多余线程最大存活时间"></node><node CREATED="1593745252662" ID="ID_2ebac3df48f1" MODIFIED="1593745252662" TEXT="unit 存活时间的单位"></node><node CREATED="1593745252662" ID="ID_800f6b367839" MODIFIED="1593745252662" TEXT="workQueue 存放任务的队列(阻塞队列)，在任意时刻，不论并发有多高，永远只有一个线程能够进行入队或出队操作"></node><node CREATED="1593745252662" ID="ID_6c0473861da8" MODIFIED="1593745252662" TEXT="handler 超出线程范围和队列容量的任务的处理程序"></node><node CREATED="1593745252662" ID="ID_1985ec745074" MODIFIED="1593745252662" TEXT="ThreadFactory 线程工厂"></node></node></node><node CREATED="1593745252662" ID="ID_f1a36efb5c5d" MODIFIED="1593745252662" TEXT="线程池的实现原理"><node CREATED="1593745252662" ID="ID_51ae42b7b7a0" MODIFIED="1593745252662" TEXT="提交一个任务到线程池，线程池判断线程池里的核心线程是否都在执行任务，如果不是，则创建一个新的工作线程来执行任务。如果核心线程都在执行任务，就进行下个流程"></node><node CREATED="1593745252662" ID="ID_76fa55a8ec65" MODIFIED="1593745252662" TEXT="线程池判断工作队列是否已满，如果工作队列没有满，则将新提交的任务存储在这个工作队列里，如果工作队列满了，则进入下个流程"></node><node CREATED="1593745252662" ID="ID_9c5dd0be458f" MODIFIED="1593745252662" TEXT="判断线程池里的线程是否都处于工作状态，如果没有，则创建一个新的工作线程来执行任务，如果已经满了，则交给饱和策略（直接抛出异常、只用调用所在的线程运行任务、丢弃队列里最近的一个任务，并执行当前任务、不处理，丢弃掉）来处理这个任务"></node></node><node CREATED="1593745252662" ID="ID_63f336c653ab" MODIFIED="1593745252662" TEXT="线程池的关闭方式"><node CREATED="1593745252662" ID="ID_5111b5f19254" MODIFIED="1593745252662" TEXT="shutdown()"><node CREATED="1593745252662" ID="ID_f6c056824075" MODIFIED="1593745252662" TEXT="shutdown()后线程池将变成shutdown状态，此时不接收新任务，但会处理正在运行的和在阻塞队列中等待处理的任务"></node></node><node CREATED="1593745252662" ID="ID_fe1383e96d4d" MODIFIED="1593745252662" TEXT="shutdownNow()"><node CREATED="1593745252662" ID="ID_f791fa94efb7" MODIFIED="1593745252662" TEXT="shutdownNow()后线程池将变成stop状态，此时不接收新任务，不再处理在阻塞队列中等待的任务，还会尝试中断正在处理中的工作线程。"></node></node></node><node CREATED="1593745252662" ID="ID_b7b9ad790278" MODIFIED="1593745252662" TEXT="什么时候使用线程池"><node CREATED="1593745252662" ID="ID_018d3ba1c46f" MODIFIED="1593745252662" TEXT="单个任务处理时间比较短"><node CREATED="1593745252662" ID="ID_e2d30c811cb5" MODIFIED="1593745252662" TEXT="防止任务堆积"></node></node><node CREATED="1593745252662" ID="ID_3f428e150ce9" MODIFIED="1593745252662" TEXT="需要处理的任务数量很大"></node></node><node CREATED="1593745252662" ID="ID_efc25dda339e" MODIFIED="1593745252662" TEXT="线程池里线程数量的确定"><node CREATED="1593745252662" ID="ID_f9b5f4e23c3f" MODIFIED="1593745252662" TEXT="CPU密集型"><node CREATED="1593745252662" ID="ID_9f4a6c373ffa" MODIFIED="1593745252662" TEXT="任务需要大量的运算，需要将线程与核心对应，即取cpu核心数+1个线程"></node></node><node CREATED="1593745252662" ID="ID_49f1faef5ce9" MODIFIED="1593745252662" TEXT="IO密集型"><node CREATED="1593745252662" ID="ID_dbc0aae0ad44" MODIFIED="1593745252662" TEXT="有大量的IO操作，如读取数据库，即会有线程阻塞，所以多个线程轮流，利用cpu资源，取CPU核数*2"></node></node></node></node><node CREATED="1593745252662" ID="ID_8f8cb9ebf254" MODIFIED="1593745252662" TEXT="java同步机制"><node CREATED="1593745252662" ID="ID_1706348ffdb4" MODIFIED="1593745252662" TEXT="synchronized"></node><node CREATED="1593745252662" ID="ID_ed66531afaa7" MODIFIED="1593745252662" TEXT="wait、notify"></node><node CREATED="1593745252662" ID="ID_996f458b27bb" MODIFIED="1593745252662" TEXT="ThreadLocal机制"></node></node><node CREATED="1593745252662" ID="ID_6d07e4e1b068" MODIFIED="1593745252662" TEXT="锁的相关概念"><node CREATED="1593745252662" ID="ID_1edc35d7de5e" MODIFIED="1593745252662" TEXT="可重入锁"><node CREATED="1593745252662" ID="ID_e1bee8532a30" MODIFIED="1593745252662" TEXT="一个线程执行某个同步方法，该同步方法调用另一个同步方法，则该线程不需要再重新申请锁，而是直接执行另一个方法"></node></node><node CREATED="1593745252662" ID="ID_8134e22f18f5" MODIFIED="1593745252662" TEXT="可中断锁"><node CREATED="1593745252662" ID="ID_3fc8312d31be" MODIFIED="1593745252662" TEXT="synchronized是不可中断锁，lock是可中断锁"></node><node CREATED="1593745252662" ID="ID_fcdc59255bfe" MODIFIED="1593745252662" TEXT="线程A正在执行锁中的代码，另一线程B正在等待获取该锁，可能由于等待时间过长，线程B不想等待了，想先处理其他事情，我们可以让它中断自己或者在别的线程中中断它"></node></node><node CREATED="1593745252662" ID="ID_95f90651cb37" MODIFIED="1593745252662" TEXT="公平锁"><node CREATED="1593745252662" ID="ID_31382568a07b" MODIFIED="1593745252662" TEXT="尽量以请求锁的顺序来获取锁"></node></node></node><node CREATED="1593745252662" ID="ID_75ae9d719e1d" MODIFIED="1593745252662" TEXT="如何减少线程上下文切换"><node CREATED="1593745252662" ID="ID_e9492578ed12" MODIFIED="1593745252662" TEXT="无锁并发编程"><node CREATED="1593745252662" ID="ID_a440819e9971" MODIFIED="1593745252662" TEXT="多线程处理数据时，用一些办法避免使用锁，如将数据的ID按照Hash取模分段，不同的线程处理不同段的数据"></node></node><node CREATED="1593745252662" ID="ID_06e31875eed9" MODIFIED="1593745252662" TEXT="CAS"><node CREATED="1593745252662" ID="ID_bdc95c598781" MODIFIED="1593745252662" TEXT="Java的Atomic包使用CAS算法更新数据，而不需要加锁"></node></node><node CREATED="1593745252662" ID="ID_d61a75f481ac" MODIFIED="1593745252662" TEXT="控制线程数量"><node CREATED="1593745252662" ID="ID_51f81ed981da" MODIFIED="1593745252662" TEXT="控制线程数量，避免创建不需要的线程，造成大量线程都处于等待状态"></node></node><node CREATED="1593745252662" ID="ID_0e17a0e847f1" MODIFIED="1593745252662" TEXT="协程"><node CREATED="1593745252662" ID="ID_89115a8c94e8" MODIFIED="1593745252662" TEXT="在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换"></node></node></node></node><node CREATED="1593745252662" ID="ID_487cbe102a97" MODIFIED="1593745252662" TEXT="进程的状态与切换"><node CREATED="1593745252662" ID="ID_db8aa4e7eed9" MODIFIED="1593745252662" TEXT="进程状态"><node CREATED="1593745252662" ID="ID_d085e8260dbe" MODIFIED="1593745252662" TEXT="新建"></node><node CREATED="1593745252662" ID="ID_06d2c225b83b" MODIFIED="1593745252662" TEXT="就绪"></node><node CREATED="1593745252662" ID="ID_849af64479ab" MODIFIED="1593745252662" TEXT="运行"></node><node CREATED="1593745252662" ID="ID_af2b30446f9c" MODIFIED="1593745252662" TEXT="阻塞"></node><node CREATED="1593745252662" ID="ID_217bc824e750" MODIFIED="1593745252662" TEXT="终止"></node></node><node CREATED="1593745252662" ID="ID_c86e39a4931d" MODIFIED="1593745252662" TEXT="状态切换"><node CREATED="1593745252662" ID="ID_9fc2d5c3aea2" MODIFIED="1593745252662" TEXT="就绪态-&amp;gt;运行态"><node CREATED="1593745252662" ID="ID_6385322c5396" MODIFIED="1593745252662" TEXT="得到处理机调度"></node></node><node CREATED="1593745252662" ID="ID_0b81b73ca978" MODIFIED="1593745252662" TEXT="运行态-&amp;gt;就绪态"><node CREATED="1593745252662" ID="ID_57f18d4de1d9" MODIFIED="1593745252662" TEXT="时间片用完；更高优先级的进程就绪时，可以调度优先级更高的程序执行"></node></node><node CREATED="1593745252662" ID="ID_68ef33f4522b" MODIFIED="1593745252662" TEXT="运行态-&amp;gt;阻塞态"><node CREATED="1593745252662" ID="ID_02175ab34764" MODIFIED="1593745252662" TEXT="请求资源失败"></node></node><node CREATED="1593745252662" ID="ID_2cbede2a7432" MODIFIED="1593745252662" TEXT="阻塞态-&amp;gt;就绪态"><node CREATED="1593745252662" ID="ID_3c97df3e1075" MODIFIED="1593745252662" TEXT="资源来了"></node></node></node><node CREATED="1593745252662" ID="ID_6ea3f9c59a21" MODIFIED="1593745252662" TEXT="一个进程由运行态到阻塞态是主动的行为，而阻塞态变成就绪态是被动行为，需要其他相关进程的协助"></node></node><node CREATED="1593745252662" ID="ID_d7564b93fff2" MODIFIED="1593745252662" TEXT="线程模型"><node CREATED="1593745252662" ID="ID_2e0bcbc4cac9" MODIFIED="1593745252662" TEXT="用户线程(ULT)"><node CREATED="1593745252662" ID="ID_53e80af6ba22" MODIFIED="1593745252662" TEXT="由应用管理，应用提供创建，同步，调度等操作。不需要用户态/核心态切换"></node><node CREATED="1593745252662" ID="ID_10e364aaf316" MODIFIED="1593745252662" TEXT="为什么有用户态到核心态的切换"><node CREATED="1593745252662" ID="ID_6207f91694a3" MODIFIED="1593745252662" TEXT="内存分为用户空间和核心空间，当应用需要调用硬件时，需要内核线程调用"></node></node></node><node CREATED="1593745252662" ID="ID_50829ada95b9" MODIFIED="1593745252662" TEXT="内核线程(KLT)"><node CREATED="1593745252662" ID="ID_57f2c1470373" MODIFIED="1593745252662" TEXT="由操作系统管理"></node></node><node CREATED="1593745252662" ID="ID_7ddd611cb0e8" MODIFIED="1593745252662" TEXT="JVM在用户空间创建线程，通过库调度器，调用系统库创建内核线程。cpu通过调度算法调用内核线程"></node></node><node CREATED="1593745252662" ID="ID_fc5165bb2389" MODIFIED="1593745252662" TEXT="进程间通信的方式"><node CREATED="1593745252662" ID="ID_7e473104bd45" MODIFIED="1593745252662" TEXT="共享内存"><node CREATED="1593745252662" ID="ID_de4039535874" MODIFIED="1593745252662" TEXT="多个进程地址空间映射到同一块内存中"><node CREATED="1593745252662" ID="ID_d6d975247c44" MODIFIED="1593745252662" TEXT="内存映射文件"></node></node></node><node CREATED="1593745252662" ID="ID_fec887df0f8d" MODIFIED="1593745252662" TEXT="管道"><node CREATED="1593745252662" ID="ID_5051859467cc" MODIFIED="1593745252662" TEXT="管道"><node CREATED="1593745252662" ID="ID_f2516e530961" MODIFIED="1593745252662" TEXT="用于连接一个读进程和一个写进程以实现它们之间通信的一个共享文件，只存在于内存中"></node></node><node CREATED="1593745252662" ID="ID_393349fbb1c2" MODIFIED="1593745252662" TEXT="写进程以字符流形式将大量的数据送入管道；读进程从管道中接收数据"></node><node CREATED="1593745252662" ID="ID_c7f961a0a1e7" MODIFIED="1593745252662" TEXT="只支持半双工通信（单向交替传输）"></node><node CREATED="1593745252662" ID="ID_3ad48a9cc360" MODIFIED="1593745252662" TEXT="只能在亲源进程中使用"></node></node><node CREATED="1593745252662" ID="ID_0704414ef02e" MODIFIED="1593745252662" TEXT="有名管道"><node CREATED="1593745252662" ID="ID_3ffc925d9d91" MODIFIED="1593745252662" TEXT="去除了管道只能在父子进程中使用的限制"></node></node><node CREATED="1593745252662" ID="ID_4340a1e83012" MODIFIED="1593745252662" TEXT="消息队列"><node CREATED="1593745252663" ID="ID_c4cbb1f02f2d" MODIFIED="1593745252663" TEXT="消息队列是消息的链表，存放在内核中并由消息队列标识符表示，提供了一个从一个进程向另一个进程发送数据快的方法"></node><node CREATED="1593745252663" ID="ID_9755ba4fa426" MODIFIED="1593745252663" TEXT="特点"><node CREATED="1593745252663" ID="ID_93dd769ddde6" MODIFIED="1593745252663" TEXT="生命周期随内核，消息队列会一直存在，需要我们显示的调用接口删除或使用命令删除"></node><node CREATED="1593745252663" ID="ID_ddb21e3c0728" MODIFIED="1593745252663" TEXT="消息队列可以双向通信"></node><node CREATED="1593745252663" ID="ID_4bac617370aa" MODIFIED="1593745252663" TEXT="克服了管道只能承载无格式字节流的缺点"></node><node CREATED="1593745252663" ID="ID_40c068701f64" MODIFIED="1593745252663" TEXT="消息队列可以实现消息的随机查询，消息不一定要以先进先出的次序读取，也可以按消息的类型读取"></node></node></node><node CREATED="1593745252663" ID="ID_670b823db0c8" MODIFIED="1593745252663" TEXT="客户机-服务器系统通信"><node CREATED="1593745252663" ID="ID_5439166fe7db" MODIFIED="1593745252663" TEXT="套接字(socket)"></node><node CREATED="1593745252663" ID="ID_a556b53ad695" MODIFIED="1593745252663" TEXT="远程过程调用"><node CREATED="1593745252663" ID="ID_144aca282e53" MODIFIED="1593745252663" TEXT="通过RPC协议，允许运行于一台主机系统上的进程调用另一台主机系统的进程"></node></node></node><node CREATED="1593745252663" ID="ID_7ccd8c84988d" MODIFIED="1593745252663" TEXT="信号量"><node CREATED="1593745252663" ID="ID_6fe72b9f47ef" MODIFIED="1593745252663" TEXT="是一个计数器，用于为多个进程提供共享数据对象的访问"></node><node CREATED="1593745252663" ID="ID_d8b11f6dd7a7" MODIFIED="1593745252663" TEXT="它常作为一种锁的机制，防止某进程正在访问共享资源时，其他进程也访问该资源。主要作为不同进程或者同一进程之间不同线程之间同步的手段"></node></node></node><node CREATED="1593745252663" ID="ID_fb7575c694bc" MODIFIED="1593745252663" TEXT="进程同步"><node CREATED="1593745252663" ID="ID_135130a748ae" MODIFIED="1593745252663" TEXT="临界区"><node CREATED="1593745252663" ID="ID_ed68d3d2c2ed" MODIFIED="1593745252663" TEXT="对临界资源进行访问的代码称为临界区"></node><node CREATED="1593745252663" ID="ID_8705f1da071c" MODIFIED="1593745252663" TEXT="为了互斥访问临界资源，每个进程在进入临界区之前，需要先进行检查"></node></node><node CREATED="1593745252663" ID="ID_0f31a7a2d670" MODIFIED="1593745252663" TEXT="信号量"><node CREATED="1593745252663" ID="ID_6a367c110ad6" MODIFIED="1593745252663" TEXT="用于进程间传递信号的一个整数值"></node><node CREATED="1593745252663" ID="ID_141cf9f6a9de" MODIFIED="1593745252663" TEXT="pv"></node></node><node CREATED="1593745252663" ID="ID_5c42bd0f80fe" MODIFIED="1593745252663" TEXT="管程"><node CREATED="1593745252663" ID="ID_368f3a40ac21" MODIFIED="1593745252663" TEXT="由若干个变量以及方法所组织成的一种特殊的结构"></node><node CREATED="1593745252663" ID="ID_56be818865e9" MODIFIED="1593745252663" TEXT="将分散在各个进程中的临界区集中起来进行统一控制和管理，并且将系统中的共享资源用数据结构抽象的描述出来，然后对临界区的访问通过管程进行统一管理"></node><node CREATED="1593745252663" ID="ID_52ec6d8f4d60" MODIFIED="1593745252663" TEXT="特性"><node CREATED="1593745252663" ID="ID_c49cf3babb4c" MODIFIED="1593745252663" TEXT="互斥性"><node CREATED="1593745252663" ID="ID_dba417bf4db6" MODIFIED="1593745252663" TEXT="任何时刻只能最多一个进程进入管程活动，其他想进入必须等待"></node></node><node CREATED="1593745252663" ID="ID_318333d018d1" MODIFIED="1593745252663" TEXT="安全性"><node CREATED="1593745252663" ID="ID_bc37aa850c5e" MODIFIED="1593745252663" TEXT="管程中的局部变量只能由管程的方法访问，其他进程或管程不能够对该局部变量进行直接访问"></node></node><node CREATED="1593745252663" ID="ID_57dba360eacb" MODIFIED="1593745252663" TEXT="共享性"><node CREATED="1593745252663" ID="ID_1b198f9812d0" MODIFIED="1593745252663" TEXT="管程中的特定的方法可以被其他管程或进程访问，这样的方法有特殊说明"></node></node></node></node></node><node CREATED="1593745252663" ID="ID_c66f7d3f3f86" MODIFIED="1593745252663" TEXT="线程间通信的方式"><node CREATED="1593745252663" ID="ID_df6cc552a792" MODIFIED="1593745252663" TEXT="加锁"><node CREATED="1593745252663" ID="ID_230a66679029" MODIFIED="1593745252663" TEXT="synchronized加锁的线程中的 wait()/notify()"></node><node CREATED="1593745252663" ID="ID_cd754ebd8888" MODIFIED="1593745252663" TEXT="lock中condition类的await()/signal()"></node></node><node CREATED="1593745252663" ID="ID_965cbb541014" MODIFIED="1593745252663" TEXT="管道"><node CREATED="1593745252663" ID="ID_38e97977253c" MODIFIED="1593745252663" TEXT="管道流用于在不同线程间直接传送数据"></node><node CREATED="1593745252663" ID="ID_89696a9bb474" MODIFIED="1593745252663" TEXT="一个线程发送数据到输出管道，另一个线程从输入管道读数据"></node></node></node><node CREATED="1593745252663" ID="ID_58ac14bd6416" MODIFIED="1593745252663" TEXT="wait() notify() notifyAll()的区别"><node CREATED="1593745252663" ID="ID_c4846aa38a3b" MODIFIED="1593745252663" TEXT="wait: 线程自动释放其占有的对象锁，并等待notify()"></node><node CREATED="1593745252663" ID="ID_5997ec965a60" MODIFIED="1593745252663" TEXT="notify: 唤醒一个正在wait当前对象锁的线程，并让它拿到对象锁"></node><node CREATED="1593745252663" ID="ID_b929ecd7eb00" MODIFIED="1593745252663" TEXT="notifyAll：唤醒所有正在wait当前对象锁的线程"></node></node><node CREATED="1593745252663" ID="ID_c4d21a5f1169" MODIFIED="1593745252663" TEXT="死锁"><node CREATED="1593745252663" ID="ID_da4b90b331bc" MODIFIED="1593745252663" TEXT="死锁的必要条件"><node CREATED="1593745252663" ID="ID_42255d0c76b0" MODIFIED="1593745252663" TEXT="互斥条件"></node><node CREATED="1593745252663" ID="ID_adbf817e151e" MODIFIED="1593745252663" TEXT="不可抢占条件"></node><node CREATED="1593745252663" ID="ID_0541b1d82738" MODIFIED="1593745252663" TEXT="请求和保持"></node><node CREATED="1593745252663" ID="ID_3f9a26d24bf9" MODIFIED="1593745252663" TEXT="环路等待"></node></node><node CREATED="1593745252663" ID="ID_655646195ea6" MODIFIED="1593745252663" TEXT="解决死锁的方法"><node CREATED="1593745252663" ID="ID_46219d66f912" MODIFIED="1593745252663" TEXT="死锁检测和死锁恢复"></node><node CREATED="1593745252663" ID="ID_1552134fd2c7" MODIFIED="1593745252663" TEXT="死锁预防"></node><node CREATED="1593745252663" ID="ID_8b1f65ce6b1f" MODIFIED="1593745252663" TEXT="死锁避免"></node><node CREATED="1593745252663" ID="ID_e2c0c5f3aaa3" MODIFIED="1593745252663" TEXT="鸵鸟策略"></node></node></node><node CREATED="1593745252663" ID="ID_30e160631c3b" MODIFIED="1593745252663" TEXT="进程和线程的区别"><node CREATED="1593745252663" ID="ID_0aecf602b5ce" MODIFIED="1593745252663" TEXT="一个进程由一个或多个线程组成，线程是一个进程中代码的不同执行路线"></node><node CREATED="1593745252663" ID="ID_95a0d2e25b38" MODIFIED="1593745252663" TEXT="拥有资源：进程是资源分配的基本单位，线程几乎不拥有资源（只需要少量的资源(指令指针IP，寄存器，栈），线程可以访问隶属进程的资源"></node><node CREATED="1593745252663" ID="ID_521a131db5b0" MODIFIED="1593745252663" TEXT="通信方面：线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助IPC"></node><node CREATED="1593745252663" ID="ID_1f2d27cd1fd8" MODIFIED="1593745252663" TEXT="调度：线程是独立调度的基本单位，在统一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程会引起进程切换"></node><node CREATED="1593745252663" ID="ID_e8a1c884f644" MODIFIED="1593745252663" TEXT="系统开销：创建和销毁进程时，系统都要为之分配和回收资源，如内存空间、I/O设备等，所符出的开销远大于创建或撤销线程时的开销。类似的，在进行进程切换时，设计当前执行进程CPU环境的保存及新调度进程CPU环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小"></node></node><node CREATED="1593745252663" ID="ID_fbc92939011b" MODIFIED="1593745252663" TEXT="进程调度的基本方式"><node CREATED="1593745252663" ID="ID_f313363ebc4a" MODIFIED="1593745252663" TEXT="时间片轮转"></node><node CREATED="1593745252663" ID="ID_f4893a152f91" MODIFIED="1593745252663" TEXT="优先级调度"></node><node CREATED="1593745252663" ID="ID_0062ea30bc90" MODIFIED="1593745252663" TEXT="多级反馈队列"></node></node><node CREATED="1593745252663" ID="ID_7966cab4c58f" MODIFIED="1593745252663" TEXT="进程同步和进程通信的区别"><node CREATED="1593745252663" ID="ID_73cc66318973" MODIFIED="1593745252663" TEXT="进程同步：控制多个进程按一定顺序执行"></node><node CREATED="1593745252663" ID="ID_29606dd3512e" MODIFIED="1593745252663" TEXT="进程通信：进程间传输信息"></node></node><node CREATED="1593745252663" ID="ID_d0e20429c4e6" MODIFIED="1593745252663" TEXT="sleep()和wait()的区别"><node CREATED="1593745252663" ID="ID_52cbf7dc34f9" MODIFIED="1593745252663" TEXT="当在一个Synchronized方法中调用sleep()时，线程虽然休眠了，但是对象的机锁没有被释放，其他线程任然不可以访问这个对象"></node><node CREATED="1593745252663" ID="ID_b2b7d2d930f2" MODIFIED="1593745252663" TEXT="wait()方法则会在线程休眠的同时释放掉机锁，其他线程可以访问该对象。"></node><node CREATED="1593745252663" ID="ID_92ed0a1c3eab" MODIFIED="1593745252663" TEXT="Yield()方法是停止当前线程，让同等优先权的线程运行。如果没有同等优先权的线程，那么Yield() 方法将不会起作用。"></node><node CREATED="1593745252663" ID="ID_cb97f564d57c" MODIFIED="1593745252663" TEXT="join()方法使当前线程停下来等待，直至另一个调用join方法的线程终止。"></node></node><node CREATED="1593745252663" ID="ID_5ac111959ebb" MODIFIED="1593745252663" TEXT="AQS"><node CREATED="1593745252663" ID="ID_c0297da9efd8" MODIFIED="1593745252663" TEXT="同步队列"><node CREATED="1593745252663" ID="ID_ef0b1275fc0a" MODIFIED="1593745252663" TEXT="一个虚拟双端队列，遵循FIFO原则，主要作用是用来存放在锁上阻塞的线程，当一个线程尝试获取锁时，如果已经被占用，那么当前线程就会被构造成一个Node节点加入到同步队列的尾部，队列的头节点是成功获取锁的节点，当头节点线程释放锁时，会唤醒后面的节点并释放当前头节点的引用"></node></node></node><node CREATED="1593745252663" ID="ID_572189cc58d1" MODIFIED="1593745252663" TEXT="静态链接和动态链接"><node CREATED="1593745252663" ID="ID_03d88957710a" MODIFIED="1593745252663" TEXT="静态链接"><node CREATED="1593745252663" ID="ID_fce5d99cff6d" MODIFIED="1593745252663" TEXT="在生成可执行程序的时候，把目标文件和静态库，使用Id连接器，链接生成一个可执行程序"></node></node><node CREATED="1593745252663" ID="ID_a1becc7687aa" MODIFIED="1593745252663" TEXT="动态链接"><node CREATED="1593745252663" ID="ID_0fb38cecd46a" MODIFIED="1593745252663" TEXT="在生成可执行程序的时候，只是引用的未定义的符号作了标识，到加载到内存中的时候才进行符号重定位"></node></node></node><node CREATED="1593745252663" ID="ID_3dd8afa89dc3" MODIFIED="1593745252663" TEXT="守护线程"><node CREATED="1593745252663" ID="ID_408724152cd0" MODIFIED="1593745252663" TEXT="守护线程是程序运行时在后台提供服务的线程，不属于程序中不可或缺的部分"></node><node CREATED="1593745252663" ID="ID_a955279910fb" MODIFIED="1593745252663" TEXT="当所有非守护线程结束时，程序也就终止，同时会杀死所有守护线程"></node></node><node CREATED="1593745252663" ID="ID_1ae03771e37d" MODIFIED="1593745252663" TEXT="并行和并发的区别"><node CREATED="1593745252663" ID="ID_0e1a8a2b1c9e" MODIFIED="1593745252663" TEXT="并行是指两个或多个事件在同一时刻发生，并发是指两个或多个事件在同一时间间隔发生"></node><node CREATED="1593745252663" ID="ID_2e9b9393962f" MODIFIED="1593745252663" TEXT="并行是在不同实体上的多个事件，并发是在同一实体上的多个事件"></node><node CREATED="1593745252663" ID="ID_89e2d23e61b9" MODIFIED="1593745252663" TEXT="在一台处理器上“同时”处理多个任务，在多台处理器上同时处理多个任务"></node></node><node CREATED="1593745252663" ID="ID_6f2896ff569d" MODIFIED="1593745252663" TEXT="fork()和exec()"><node CREATED="1593745252663" ID="ID_115a6d87185c" MODIFIED="1593745252663" TEXT="fork()"><node CREATED="1593745252663" ID="ID_051c2ad3b867" MODIFIED="1593745252663" TEXT="Linux的进程都通过init进程或init进程的子进程fork出来的"></node><node CREATED="1593745252663" ID="ID_6d4ea7ccdf72" MODIFIED="1593745252663" TEXT="fork()会产生一个和父进程完全相同的子进程（除了pid）"></node></node><node CREATED="1593745252663" ID="ID_ed054231b2b6" MODIFIED="1593745252663" TEXT="exec()"><node CREATED="1593745252663" ID="ID_7ab7256ab940" MODIFIED="1593745252663" TEXT="装载一个新的程序(可执行映像)覆盖当前进程内存空间中的映像，从而执行不同的任务"></node><node CREATED="1593745252663" ID="ID_2bf46b95df7b" MODIFIED="1593745252663" TEXT="exec()系列函数在执行时会直接替换掉当前进程的地址空间"></node></node></node><node CREATED="1593745252663" ID="ID_8dba83f97750" MODIFIED="1593745252663" TEXT="锁的膨胀"><node CREATED="1593745252663" ID="ID_34003b3d9a53" MODIFIED="1593745252663" LINK="https://www.cnblogs.com/twoheads/p/10148598.html" TEXT="https://www.cnblogs.com/twoheads/p/10148598.html"></node></node></node><node CREATED="1593745252663" ID="ID_df2acd297dd4" POSITION="right" MODIFIED="1593745252663" TEXT="集合框架"><node CREATED="1593745252663" ID="ID_0117180b163b" MODIFIED="1593745252663" TEXT="ArrayList与LinkedList异同"><node CREATED="1593745252663" ID="ID_19d1421164ed" MODIFIED="1593745252663" TEXT="是否保证线程安全"><node CREATED="1593745252663" ID="ID_a273f9351899" MODIFIED="1593745252663" TEXT="ArrayList和LinkedList都是不同步的，也就是不保证线程安全"></node></node><node CREATED="1593745252663" ID="ID_c5f91f04caf2" MODIFIED="1593745252663" TEXT="底层数据结构"><node CREATED="1593745252663" ID="ID_c9f6ddb172d7" MODIFIED="1593745252663" TEXT="ArrayList底层使用的是Object数组"></node><node CREATED="1593745252663" ID="ID_da7f6a35cc08" MODIFIED="1593745252663" TEXT="LinkedList底层使用的双向循环链表数据结构"></node></node><node CREATED="1593745252663" ID="ID_fd21a856d53d" MODIFIED="1593745252663" TEXT="插入和删除是否受元素位置的影响"><node CREATED="1593745252663" ID="ID_02fa0c1a4b1d" MODIFIED="1593745252663" TEXT="ArrayList采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响，插入不指定位置，时间复杂度为O(1),指定插入位置的话，时间复杂度为O(n)"></node><node CREATED="1593745252663" ID="ID_fc5e51aee5d5" MODIFIED="1593745252663" TEXT="LinkedList采用链表存储，所以插入，删除元素时间复杂度不受元素位置的影响，都是近似O(1)，查询近似O(n)"></node></node><node CREATED="1593745252663" ID="ID_f561b10f9d00" MODIFIED="1593745252663" TEXT="是否支持快速随机访问"><node CREATED="1593745252663" ID="ID_200a005f749a" MODIFIED="1593745252663" TEXT="LinkedList不支持高效的随机元素访问"></node><node CREATED="1593745252663" ID="ID_a15822ad6118" MODIFIED="1593745252663" TEXT="ArrayList实现了RandmoAcess接口，所有有随机访问功能。快速随机访问就是通过元素的序号快速获取元素对象"></node></node><node CREATED="1593745252663" ID="ID_d261a0c20986" MODIFIED="1593745252663" TEXT="内存空间占用"><node CREATED="1593745252663" ID="ID_b0b7cc48cf35" MODIFIED="1593745252663" TEXT="ArrayList的空间浪费主要体现在list列表的结尾会预留一定的容量空间"></node><node CREATED="1593745252663" ID="ID_8f88ed49421d" MODIFIED="1593745252663" TEXT="LinkedList的空间浪费体现在它的每一个元素都需要消耗比ArrayList更多的空间(存放直接前驱和直接后继以及数据)"></node></node></node><node CREATED="1593745252663" ID="ID_6fdd9391a04a" MODIFIED="1593745252663" TEXT="&amp;nbsp;ArrayList与Vector的区别"><node CREATED="1593745252663" ID="ID_39c087141c5e" MODIFIED="1593745252663" TEXT="Vector的所有方法都是同步的，可以由两个线程安全的访问一个Vector对象，但是一个线程访问Vector的话代码要在同步操作上耗费大量的时间"></node><node CREATED="1593745252663" ID="ID_525b28f9a54c" MODIFIED="1593745252663" TEXT="ArrayList不是同步的，所以不需要保证线程安全时建议使用ArrayList"></node></node><node CREATED="1593745252663" ID="ID_b04dc1334951" MODIFIED="1593745252663" TEXT="ArrayList和Array的区别"><node CREATED="1593745252663" ID="ID_159a77e125df" MODIFIED="1593745252663" TEXT="Array可以包含基本类型和引用类型，ArrayList只能包含引用类型"></node><node CREATED="1593745252663" ID="ID_691240c109d3" MODIFIED="1593745252663" TEXT="Array大小是固定的，ArrayList的大小是动态变化的"></node></node><node CREATED="1593745252663" ID="ID_b22efd88f519" MODIFIED="1593745252663" TEXT="Hash"><node CREATED="1593745252663" ID="ID_2a51d8f8769e" MODIFIED="1593745252663" TEXT="HashMap的底层实现"><node CREATED="1593745252663" ID="ID_b3bff01c4a1b" MODIFIED="1593745252663" TEXT="JDK 1.8之前HashMap是通过 数组+链表 实现的。链表主要用来解决哈希冲突"><node CREATED="1593745252663" ID="ID_87c11baea36b" MODIFIED="1593745252663" TEXT="如果定位到的数组位置不含链表，那么对于查找、添加操作很快，为O(1)"></node><node CREATED="1593745252663" ID="ID_8cc91b8bf383" MODIFIED="1593745252663" TEXT="如果定位到的数组位置包含链表，对于添加操作，时间复杂度仍为O(1)，对于查找操作，需要遍历链表"></node></node><node CREATED="1593745252663" ID="ID_71a9d9114fd1" MODIFIED="1593745252663" TEXT="JDK 1.8之后解决哈希冲突，当链表长度大于阈值(默认为8)，采用红黑树，以减少搜索时间"></node><node CREATED="1593745252663" ID="ID_bad73e3a07cd" MODIFIED="1593745252663" TEXT="为什么1.7采用头插"><node CREATED="1593745252663" ID="ID_24a2adfa35ff" MODIFIED="1593745252663" TEXT="效率问题，尾插需要多次遍历"></node><node CREATED="1593745252663" ID="ID_055a2ba7382e" MODIFIED="1593745252663" TEXT="一贯的思维，新插入的节点要更可能被再次调用"></node></node></node><node CREATED="1593745252663" ID="ID_ba66ec404ea5" MODIFIED="1593745252663" TEXT="HashMap和HashTable的区别"><node CREATED="1593745252663" ID="ID_f80f5546a7ee" MODIFIED="1593745252663" TEXT="线程是否安全"><node CREATED="1593745252663" ID="ID_187654e1861f" MODIFIED="1593745252663" TEXT="HashMap是非线程安全的"></node><node CREATED="1593745252663" ID="ID_4696cd5b43dd" MODIFIED="1593745252663" TEXT="HashTable是线程安全的"></node></node><node CREATED="1593745252663" ID="ID_3e4861a1d35a" MODIFIED="1593745252663" TEXT="效率"><node CREATED="1593745252663" ID="ID_e29d6a61b510" MODIFIED="1593745252663" TEXT="因为要保证线程安全，所以HashMap效率要比HashTable高"></node></node><node CREATED="1593745252663" ID="ID_94cb136a56cd" MODIFIED="1593745252663" TEXT="对Null key和Null value的支持"><node CREATED="1593745252663" ID="ID_e78cc9c5ead2" MODIFIED="1593745252663" TEXT="HashMap中，null可以作为键，这样的键只有一个，可以有一个或多个键所对应的值为null"></node><node CREATED="1593745252663" ID="ID_c9831682c3dc" MODIFIED="1593745252663" TEXT="HashTable中，put进的键值只要有一个为null，直接抛出NullPointerException"></node></node><node CREATED="1593745252663" ID="ID_3282f5ee904b" MODIFIED="1593745252663" TEXT="初始容量大小和每次扩充容量大小的不同"><node CREATED="1593745252663" ID="ID_3fef23739a9e" MODIFIED="1593745252663" TEXT="HashMap默认的初始化大小为16，每次扩充，容量变为原来的2倍。当初始给出大小后，HashMap会将其扩充到2的幂次方"></node><node CREATED="1593745252663" ID="ID_20db47e39d8f" MODIFIED="1593745252663" TEXT="HashTable初始的容量大小为11，每次扩容，容量变为原来的2n+1"></node></node></node><node CREATED="1593745252663" ID="ID_60832a81466e" MODIFIED="1593745252663" TEXT="为什么HashMap的长度是2的幂次方"><node CREATED="1593745252663" ID="ID_8fbef7e185cf" MODIFIED="1593745252663" TEXT="HashMap为了存取高效，减少冲突，尽量将数据分配均匀，使用取模 (hash%(length-1)),计算机中hash&amp;amp;(length-1)效率更高，只有length是2的n次方时， hash%(length-1) == hash&amp;amp;(length-1)&amp;nbsp;"></node></node><node CREATED="1593745252663" ID="ID_af05b7161fbe" MODIFIED="1593745252663" TEXT="为什么HashMap的加载因子是0.75&amp;lt;br&amp;gt;"><node CREATED="1593745252663" ID="ID_c5e28f8928e8" MODIFIED="1593745252663" TEXT="因子大，链表长度越长，扩容耗时长"></node><node CREATED="1593745252663" ID="ID_2e176ac27f52" MODIFIED="1593745252663" TEXT="因子小，扩容频繁，空间浪费&amp;lt;br&amp;gt;"></node></node><node CREATED="1593745252663" ID="ID_1185584e746a" MODIFIED="1593745252663" TEXT="HashMap和HashSet的区别"><node CREATED="1593745252663" ID="ID_1066a2df10bc" MODIFIED="1593745252663" TEXT="实现接口"><node CREATED="1593745252663" ID="ID_5e797998f1ec" MODIFIED="1593745252663" TEXT="HashMap实现Map接口"></node><node CREATED="1593745252663" ID="ID_b8436fbedd46" MODIFIED="1593745252663" TEXT="HashSet实现Set接口"></node></node><node CREATED="1593745252663" ID="ID_4a9707d74de8" MODIFIED="1593745252663" TEXT="存储对象"><node CREATED="1593745252663" ID="ID_80af4656bb7e" MODIFIED="1593745252663" TEXT="HashMap存储键值对"></node><node CREATED="1593745252663" ID="ID_a98dd49ef660" MODIFIED="1593745252663" TEXT="HashSet仅存储对象"></node></node><node CREATED="1593745252663" ID="ID_c8cd3dabb66f" MODIFIED="1593745252663" TEXT="添加方式"><node CREATED="1593745252663" ID="ID_5fcec36f4b5f" MODIFIED="1593745252663" TEXT="HashMap调用 put() 向map中添加元素"></node><node CREATED="1593745252663" ID="ID_b5442cfc4ec3" MODIFIED="1593745252663" TEXT="HashSet调用add()方法向Set中添加元素"></node></node></node><node CREATED="1593745252663" ID="ID_9890fa42561d" MODIFIED="1593745252663" TEXT="ConCurrentHashMap与HashTable的区别"><node CREATED="1593745252663" ID="ID_0395bb1b87ad" MODIFIED="1593745252663" TEXT="底层数据结构"><node CREATED="1593745252663" ID="ID_1a24ddf69910" MODIFIED="1593745252663" TEXT="JDK 1.7的ConcurrentHashMap采用 分段的数组+链表实现，JDK1.8采用数组+链表/红黑树实现"></node><node CREATED="1593745252663" ID="ID_b9521716ccc4" MODIFIED="1593745252663" TEXT="HashTable采用数组+链表实现"></node></node><node CREATED="1593745252663" ID="ID_fd8a6f69270d" MODIFIED="1593745252663" TEXT="实现线程安全的方式"><node CREATED="1593745252663" ID="ID_0418c164f8c7" MODIFIED="1593745252663" TEXT="ConcurrentHashMap,在JDK 1.7时，对整个数组进行分割分段，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，不会出现锁竞争，提高并发访问率(默认分配16个段)"></node><node CREATED="1593745252663" ID="ID_16b4f71fa843" MODIFIED="1593745252663" TEXT="ConcurrentHashMap，在JDK 1.8直接使用Node数组 + 链表 + 红黑树的数据结构，并发控制使用 synchronized和CAS来操作。"></node><node CREATED="1593745252663" ID="ID_dbc8fd1c3f5a" MODIFIED="1593745252663" TEXT="HashTable，使用synchronized来保证线程安全，效率低"></node></node></node><node CREATED="1593745252664" ID="ID_cf6076124018" MODIFIED="1593745252664" TEXT="hashCode()与equals()的相关规定"><node CREATED="1593745252664" ID="ID_09690a1bade2" MODIFIED="1593745252664" TEXT="如果两个对象相等，则hashcode一定也是相同的"></node><node CREATED="1593745252664" ID="ID_623f424d2326" MODIFIED="1593745252664" TEXT="两个对象相等，对两个对象分别调用equals方法都返回true"></node><node CREATED="1593745252664" ID="ID_2c630571d903" MODIFIED="1593745252664" TEXT="两个对象有相同的hashcode值，他们也不一定是相等的"></node><node CREATED="1593745252664" ID="ID_ae1ac154bc7f" MODIFIED="1593745252664" TEXT="重写equals()方法，hashcode方法也必须重写"></node></node><node CREATED="1593745252664" ID="ID_81d4322d4562" MODIFIED="1593745252664" TEXT="为什么重写equals()方法一定要重写hashcode"></node><node CREATED="1593745252664" ID="ID_c48a350f0445" MODIFIED="1593745252664" TEXT="ConcurrentHashMap为什么要放弃Segment"><node CREATED="1593745252664" ID="ID_f92f522caed9" MODIFIED="1593745252664" TEXT="锁的粒度"><node CREATED="1593745252664" ID="ID_259617369c48" MODIFIED="1593745252664" TEXT="锁的粒度变细，并发度更大"></node><node CREATED="1593745252664" ID="ID_259617369c48" MODIFIED="1593745252664" TEXT="锁的粒度变细，并发度更大"></node></node><node CREATED="1593745252664" ID="ID_16b4c5d45f0a" MODIFIED="1593745252664" TEXT="get、put性能"><node CREATED="1593745252664" ID="ID_29742a605389" MODIFIED="1593745252664" TEXT="java1.7需要先hash得到segment，在hash得到具体的索引值，1.8直接通过数组加链表得到索引值"></node></node><node CREATED="1593745252664" ID="ID_68f2dc72f2d2" MODIFIED="1593745252664" TEXT="扩容"><node CREATED="1593745252664" ID="ID_1afa23529a1c" MODIFIED="1593745252664" TEXT="在jdk1.8中，其他线程可以通过检测数组中的节点决定是否对这条链表进行扩容，减小了扩容的粒度，提高了扩容的效率"></node><node CREATED="1593745252664" ID="ID_1afa23529a1c" MODIFIED="1593745252664" TEXT="在jdk1.8中，其他线程可以通过检测数组中的节点决定是否对这条链表进行扩容，减小了扩容的粒度，提高了扩容的效率"></node></node></node><node CREATED="1593745252664" ID="ID_4e3506400c62" MODIFIED="1593745252664" TEXT="ConcurrentHashMap插入流程"><node CREATED="1593745252664" ID="ID_48232a6293be" MODIFIED="1593745252664" TEXT="校验key value 值，都不能是null"></node><node CREATED="1593745252664" ID="ID_cf767819d1ac" MODIFIED="1593745252664" TEXT="得到 key 的 hash 值"></node><node CREATED="1593745252664" ID="ID_e2af07cdb0df" MODIFIED="1593745252664" TEXT="根据 hash 值找到数组下标，如果对应的位置为空，就创建一个 Node 对象用CAS方式添加到容器"></node><node CREATED="1593745252664" ID="ID_4162b60bf259" MODIFIED="1593745252664" TEXT="如果 hash 冲突，也就是对应的位置不为 null，则判断该槽是否被扩容了（-1 表示被扩容了），如果被扩容了，返回新的数组"></node><node CREATED="1593745252664" ID="ID_ef53786a272d" MODIFIED="1593745252664" TEXT="如果 hash 冲突 且 hash 值不是 -1，表示没有被扩容。则进行链表操作或者红黑树操作，注意，这里的 f 头节点被锁住了，保证了同时只有一个线程修改链表。防止出现链表成环"></node><node CREATED="1593745252664" ID="ID_d7351958d3f8" MODIFIED="1593745252664" TEXT="如果链表树超过8，则修改链表为红黑树"></node></node></node><node CREATED="1593745252664" ID="ID_e6055af7c14a" MODIFIED="1593745252664" TEXT="集合框架总结"><node CREATED="1593745252664" ID="ID_ed47c5d27784" MODIFIED="1593745252664" TEXT="Collection"><node CREATED="1593745252664" ID="ID_f1a51be2836b" MODIFIED="1593745252664" TEXT="List"><node CREATED="1593745252664" ID="ID_760da2751ebd" MODIFIED="1593745252664" TEXT="ArrayList"><node CREATED="1593745252664" ID="ID_fcdc789b0dd1" MODIFIED="1593745252664" TEXT="Object数组"></node></node><node CREATED="1593745252664" ID="ID_0c987abf3209" MODIFIED="1593745252664" TEXT="Vector"><node CREATED="1593745252664" ID="ID_00912b9beff5" MODIFIED="1593745252664" TEXT="Object数组"></node></node><node CREATED="1593745252664" ID="ID_ee2e81438294" MODIFIED="1593745252664" TEXT="LinkedList"><node CREATED="1593745252664" ID="ID_4f64d0ccdc24" MODIFIED="1593745252664" TEXT="双向循环链表"></node></node></node><node CREATED="1593745252664" ID="ID_9ce33113681e" MODIFIED="1593745252664" TEXT="Set"><node CREATED="1593745252664" ID="ID_95d007dba7bd" MODIFIED="1593745252664" TEXT="HashSet"><node CREATED="1593745252664" ID="ID_09cf3635d917" MODIFIED="1593745252664" TEXT="无序，唯一"></node><node CREATED="1593745252664" ID="ID_9baef8cff489" MODIFIED="1593745252664" TEXT="基于HashMap实现，底层采用HashMap来保存元素"></node></node><node CREATED="1593745252664" ID="ID_fb571dd0d475" MODIFIED="1593745252664" TEXT="LinkedHashSet"><node CREATED="1593745252664" ID="ID_d73e6b80c3b7" MODIFIED="1593745252664" TEXT="LinkedHashSet继承于HashSet，并且其内部是通过LinkedHashMap实现的"></node></node><node CREATED="1593745252664" ID="ID_f3632f7d9654" MODIFIED="1593745252664" TEXT="TreeSet"><node CREATED="1593745252664" ID="ID_62a6b62cd401" MODIFIED="1593745252664" TEXT="有序，唯一"></node><node CREATED="1593745252664" ID="ID_942469979196" MODIFIED="1593745252664" TEXT="红黑树实现(自平衡的二叉树)"></node></node></node><node CREATED="1593745252664" ID="ID_ea5f23632796" MODIFIED="1593745252664" TEXT="Map"><node CREATED="1593745252664" ID="ID_78dec2a9da60" MODIFIED="1593745252664" TEXT="HashMap"><node CREATED="1593745252664" ID="ID_411a213c2802" MODIFIED="1593745252664" TEXT="JDK 1.8之前采用数组 + 链表实现，后使用 数组+ 链表+ 红黑树实现"></node></node><node CREATED="1593745252664" ID="ID_ff48124cdb05" MODIFIED="1593745252664" TEXT="LinkedHashMap"><node CREATED="1593745252664" ID="ID_c568094d9bb3" MODIFIED="1593745252664" TEXT="继承自HashMap，在此基础上，增加了一条双向链表"></node></node><node CREATED="1593745252664" ID="ID_21fcb0c94f09" MODIFIED="1593745252664" TEXT="HashTable"><node CREATED="1593745252664" ID="ID_386d379977ab" MODIFIED="1593745252664" TEXT="数组+链表"></node></node><node CREATED="1593745252664" ID="ID_ef6083341384" MODIFIED="1593745252664" TEXT="TreeMap"><node CREATED="1593745252664" ID="ID_4b4f6dcbe9d2" MODIFIED="1593745252664" TEXT="红黑树"></node></node></node></node></node><node CREATED="1593745252664" ID="ID_03b1d2ab9de5" MODIFIED="1593745252664" TEXT="集合安全的ArrayList"><node CREATED="1593745252664" ID="ID_9f3b5ee4a575" MODIFIED="1593745252664" TEXT="Vector"><node CREATED="1593745252664" ID="ID_3d1c9ab1d385" MODIFIED="1593745252664" TEXT="synchronized"></node></node><node CREATED="1593745252664" ID="ID_1c21fea9a94d" MODIFIED="1593745252664" TEXT="Collections.synchronizedArrayList&amp;lt;&amp;gt;()"><node CREATED="1593745252664" ID="ID_f3922abfaa07" MODIFIED="1593745252664" TEXT="synchronized"></node></node><node CREATED="1593745252664" ID="ID_28108273d807" MODIFIED="1593745252664" TEXT="CopyOnWriteArrayList"><node CREATED="1593745252664" ID="ID_2ed02eb53879" MODIFIED="1593745252664" TEXT="copyOnWrite"><node CREATED="1593745252664" ID="ID_7e0829bb7d5a" MODIFIED="1593745252664" TEXT="A读取数据时，B修改数据，会先加锁，然后将数组复制一份，并扩容，然后在扩容的索引增加值，在返回后解锁"></node></node></node></node></node><node CREATED="1593745252664" ID="ID_49854452ba13" POSITION="right" MODIFIED="1593745252664" TEXT="redis"><node CREATED="1593745252664" ID="ID_21f6daa01f66" MODIFIED="1593745252664" TEXT="数据类型"><node CREATED="1593745252664" ID="ID_938569df019e" MODIFIED="1593745252664" TEXT="基本数据结构"><node CREATED="1593745252664" ID="ID_39c9eff50b88" MODIFIED="1593745252664" TEXT="SDS"><node CREATED="1593745252664" ID="ID_09c0670642e2" MODIFIED="1593745252664" TEXT="字节数组 char[] buf[] 保存字符串"></node><node CREATED="1593745252664" ID="ID_eb4d46b9fba2" MODIFIED="1593745252664" TEXT="int len 记录字节数组中已使用的字节数量，也是字符串的长度"></node><node CREATED="1593745252664" ID="ID_f3b607bb785a" MODIFIED="1593745252664" TEXT="int free 记录字节数组中未使用的字节数量"></node><node CREATED="1593745252664" ID="ID_b2a90ce66d5e" MODIFIED="1593745252664" TEXT="SDS优点"><node CREATED="1593745252664" ID="ID_8dcd2b7c4317" MODIFIED="1593745252664" TEXT="用len记录字符串的长度，获取字符串的长度时，时间复杂度为O(1)"></node><node CREATED="1593745252664" ID="ID_7a445a5532f1" MODIFIED="1593745252664" TEXT="不会发生溢出的问题，如果修改SDS时，空间不足，会先扩展空间，再进行修改（内部实现了动态扩展机制）"></node><node CREATED="1593745252664" ID="ID_b34dde9a78ba" MODIFIED="1593745252664" TEXT="SDS可以减少内存分配的次数（空间预分配机制）。在扩展空间时，除了分配必要的空间，还会分配额外的空闲空间"></node><node CREATED="1593745252664" ID="ID_e9f858331987" MODIFIED="1593745252664" TEXT="二进制安全，所有SDS API都会以处理二进制的方式来处理SDS存放在buf数组里的数据"></node></node></node><node CREATED="1593745252664" ID="ID_d67e74b1e005" MODIFIED="1593745252664" TEXT="链表"><node CREATED="1593745252664" ID="ID_6d04be0e31b4" MODIFIED="1593745252664" TEXT="list"><node CREATED="1593745252664" ID="ID_7e580572b3d3" MODIFIED="1593745252664" TEXT="listNode"><node CREATED="1593745252664" ID="ID_8324240cae51" MODIFIED="1593745252664" TEXT="listNode *pre 前置节点"></node><node CREATED="1593745252664" ID="ID_9ab3f6453d39" MODIFIED="1593745252664" TEXT="listNode *post 后置结点"></node><node CREATED="1593745252664" ID="ID_2ebb42b00737" MODIFIED="1593745252664" TEXT="void *value 结点的值"></node></node><node CREATED="1593745252664" ID="ID_030135225e1e" MODIFIED="1593745252664" TEXT="listNode *head 表头结点"></node><node CREATED="1593745252664" ID="ID_91c519b453eb" MODIFIED="1593745252664" TEXT="listNode *tail 表尾结点"></node><node CREATED="1593745252664" ID="ID_9a838234c1cc" MODIFIED="1593745252664" TEXT="long len 链表长度"></node><node CREATED="1593745252664" ID="ID_96d55405deee" MODIFIED="1593745252664" TEXT="void *(*dup)&amp;nbsp; 节点值复制函数"></node><node CREATED="1593745252664" ID="ID_5a5dca422480" MODIFIED="1593745252664" TEXT="void *(*free) 节点值释放函数"></node><node CREATED="1593745252664" ID="ID_545b81c2f59a" MODIFIED="1593745252664" TEXT="int (*match) 节点值对比函数"></node></node><node CREATED="1593745252664" ID="ID_56b9fc7d1b19" MODIFIED="1593745252664" TEXT="链表特性"><node CREATED="1593745252664" ID="ID_e5e8de167cc0" MODIFIED="1593745252664" TEXT="无环双向链表，获取某个节点的前置节点和后置节点的复杂度都是O(1)"></node><node CREATED="1593745252664" ID="ID_18444665c651" MODIFIED="1593745252664" TEXT="获取表头节点，表尾节点，链表节点长度的事件复杂度均为O(1)"></node><node CREATED="1593745252664" ID="ID_11c24a4109cc" MODIFIED="1593745252664" TEXT="链表使用void * 指针保存节点值，可以保存各种不同类型的值"></node></node></node><node CREATED="1593745252664" ID="ID_e64d4756e9f0" MODIFIED="1593745252664" TEXT="字典"><node CREATED="1593745252664" ID="ID_504072dd8fb8" MODIFIED="1593745252664" TEXT="数据结构"><node CREATED="1593745252664" ID="ID_8cccf1352b6c" MODIFIED="1593745252664" TEXT="dict"><node CREATED="1593745252664" ID="ID_b04fc3b341ae" MODIFIED="1593745252664" TEXT="dictType *type 类型特定函数"></node><node CREATED="1593745252664" ID="ID_12c3a9106158" MODIFIED="1593745252664" TEXT="void *privdata 私有数据"></node><node CREATED="1593745252664" ID="ID_657e074bf38f" MODIFIED="1593745252664" TEXT="dictht ht[2]&amp;nbsp; 哈希表"></node><node CREATED="1593745252664" ID="ID_943332e0acad" MODIFIED="1593745252664" TEXT="int rehashidx&amp;nbsp; rehash索引，当rehash不进行时，值为-1"></node></node><node CREATED="1593745252664" ID="ID_d6ab6b9a7ca9" MODIFIED="1593745252664" TEXT="dictht"><node CREATED="1593745252664" ID="ID_e77d107c13e5" MODIFIED="1593745252664" TEXT="dictEntry **table 哈希表数组"></node><node CREATED="1593745252664" ID="ID_f642f07c0e56" MODIFIED="1593745252664" TEXT="long size 哈希表大小"></node><node CREATED="1593745252664" ID="ID_3e4eb3a48ee6" MODIFIED="1593745252664" TEXT="long sizemark 哈希表大小掩码，用于计算索引值（总是等于size - 1）"></node><node CREATED="1593745252664" ID="ID_a5fc00f898e8" MODIFIED="1593745252664" TEXT="long used 哈希表已有节点数量&amp;nbsp;"></node></node><node CREATED="1593745252664" ID="ID_78aab02139c4" MODIFIED="1593745252664" TEXT="dictEntry"><node CREATED="1593745252664" ID="ID_2becf8e75dd4" MODIFIED="1593745252664" TEXT="void * key 键"></node><node CREATED="1593745252664" ID="ID_8324837d4801" MODIFIED="1593745252664" TEXT="值"><node CREATED="1593745252664" ID="ID_f7049a48d0f9" MODIFIED="1593745252664" TEXT="void * value"></node><node CREATED="1593745252664" ID="ID_96c4a2c3e7c6" MODIFIED="1593745252664" TEXT="unit64_tu64"></node><node CREATED="1593745252664" ID="ID_9bfc6b065549" MODIFIED="1593745252664" TEXT="unit64_ts64"></node></node><node CREATED="1593745252664" ID="ID_af16c28d1eb5" MODIFIED="1593745252664" TEXT="dictEntry *next 指向下一个哈希节点，组成链表"><node CREATED="1593745252664" ID="ID_932aa9742910" MODIFIED="1593745252664" TEXT="这个指针可以将多个哈希值相同的键值对连接在一次，以此来解决键冲突（collision）的问题"></node></node></node></node><node CREATED="1593745252664" ID="ID_948c849f8aec" MODIFIED="1593745252664" TEXT="hash值的计算"><node CREATED="1593745252664" ID="ID_873cdeec1857" MODIFIED="1593745252664" TEXT="当字典被用作数据库的底层实现，或者哈希键的底层实现时，Redis使用MurmurHash2算法来计算键的哈希值&amp;lt;br&amp;gt;"></node><node CREATED="1593745252664" ID="ID_98981cd57af5" MODIFIED="1593745252664" TEXT="优点"><node CREATED="1593745252664" ID="ID_e0e79279de46" MODIFIED="1593745252664" TEXT="即使输入的键是有规律的，算法仍能给出一个很好的随机分布性，并且算法的计算速度也非常快"></node></node></node><node CREATED="1593745252664" ID="ID_f1226af67726" MODIFIED="1593745252664" TEXT="解决键冲突"><node CREATED="1593745252664" ID="ID_498ab153654e" MODIFIED="1593745252664" TEXT="定义"><node CREATED="1593745252664" ID="ID_0856e2075746" MODIFIED="1593745252664" TEXT="当有两个或以上数量的键被分配到了哈希表数组的同一个索引上面时，我们称这些键发生了冲突"></node></node><node CREATED="1593745252664" ID="ID_f17f2bb58d25" MODIFIED="1593745252664" TEXT="解决方法&amp;lt;br&amp;gt;"><node CREATED="1593745252664" ID="ID_c99065f30d26" MODIFIED="1593745252664" TEXT="链地址法"></node><node CREATED="1593745252664" ID="ID_2570a9ccefd7" MODIFIED="1593745252664" TEXT="每个哈希表节点都有一个next指针，多个哈希表节点可以用next指针构成一个单向链表，被分配到同一个索引上的多个节点可以用这个单向链表连接起来，这就解决了键冲突的问题"></node><node CREATED="1593745252664" ID="ID_e59b8217f53d" MODIFIED="1593745252664" TEXT="因为dictEntry节点组成的链表没有指向链表表尾的指针，所以为了速度考虑，程序总是将新节点添加到链表的表头位置（复杂度为O（1）），排在其他已有节点的前面"><node CREATED="1593745252664" ID="ID_f641e19b9004" MODIFIED="1593745252664" TEXT="因为新增加的节点往往调用频率更高，所以会放在头节点"></node></node></node></node><node CREATED="1593745252664" ID="ID_3562b5ff22f9" MODIFIED="1593745252664" TEXT="rehash&amp;lt;br&amp;gt;"><node CREATED="1593745252664" ID="ID_27c93b1534fd" MODIFIED="1593745252664" TEXT="为了让哈希表的负载因子（load factor）维持在一个合理的范围之内，当哈希表保存的键值对数量太多或者太少时，程序需要对哈希表的大小进行相应的扩展或者收缩"></node><node CREATED="1593745252664" ID="ID_cdf0cfe42c88" MODIFIED="1593745252664" TEXT="大小"><node CREATED="1593745252664" ID="ID_96d9ad55b11e" MODIFIED="1593745252664" TEXT="为字典的ht[1]哈希表分配空间，这个哈希表的空间大小取决于要执行的操作，以及ht[0]当前包含的键值对数量（也即是ht[0].used属性的值）"><node CREATED="1593745252664" ID="ID_4bd904fc45a3" MODIFIED="1593745252664" TEXT="如果执行的是扩展操作，那么ht[1]的大小为第一个大于等于ht[0].used*2的2 n（2的n次方幂）"></node></node></node><node CREATED="1593745252664" ID="ID_0372dcda88e3" MODIFIED="1593745252664" TEXT="过程"><node CREATED="1593745252664" ID="ID_77755e152217" MODIFIED="1593745252664" TEXT="为ht[1]分配空间，让字典同时持有ht[0]和ht[1]两个哈希表&amp;lt;br&amp;gt;"></node><node CREATED="1593745252664" ID="ID_2f08dac419eb" MODIFIED="1593745252664" TEXT="在字典中维持一个索引计数器变量rehashidx，并将它的值设置为0，表示rehash工作正式开始&amp;lt;br&amp;gt;"></node><node CREATED="1593745252664" ID="ID_ad5f4522632e" MODIFIED="1593745252664" TEXT="在rehash进行期间，每次对字典执行添加、删除、查找或者更新操作时，程序除了执行指定的操作以外，还会顺带将ht[0]哈希表在rehashidx索引上的所有键值对rehash到ht[1]，当rehash工作完成之后，程序将rehashidx属性的值增一"></node><node CREATED="1593745252664" ID="ID_24f0a45c384d" MODIFIED="1593745252664" TEXT="随着字典操作的不断执行，最终在某个时间点上，ht[0]的所有键值对都会被rehash至ht[1]，这时程序将rehashidx属性的值设为-1，表示rehash操作已完成"></node><node CREATED="1593745252664" ID="ID_af933e0fe1bf" MODIFIED="1593745252664" TEXT="细节"><node CREATED="1593745252664" ID="ID_3b28d80256ee" MODIFIED="1593745252664" TEXT="在进行渐进式rehash的过程中，字典会同时使用ht[0]和ht[1]两个哈希表，所以在渐进式rehash进行期间，字典的删除（delete）、查找（find）、更新（update）等操作会在两个哈希表上进行。例如，要在字典里面查找一个键的话，程序会先在ht[0]里面进行查找，如果没找到的话，就会继续到ht[1]里面进行查找，诸如此类。另外，在渐进式rehash执行期间，新添加到字典的键值对一律会被保存到ht[1]里面，而ht[0]则不再进行任何添加操作，这一措施保证了ht[0]包含的键值对数量会只减不增，并随着rehash操作的执行而最终变成空表"></node></node></node><node CREATED="1593745252664" ID="ID_ee366f613a1e" MODIFIED="1593745252664" TEXT="rehash触发条件"><node CREATED="1593745252664" ID="ID_1c6e7be6e0da" MODIFIED="1593745252664" TEXT="负载因子"><node CREATED="1593745252664" ID="ID_bc36df8d9dee" MODIFIED="1593745252664" TEXT="负载因子= 哈希表已保存节点数量/哈希表大小&amp;lt;br&amp;gt;"></node></node><node CREATED="1593745252664" ID="ID_1696614950a0" MODIFIED="1593745252664" TEXT="当哈希表的负载因子小于0.1时，程序自动开始对哈希表执行收缩操作"></node><node CREATED="1593745252664" ID="ID_5fd743899501" MODIFIED="1593745252664" TEXT="服务器目前没有在执行BGSAVE命令或者BGREWRITEAOF命令，并且哈希表的负载因子大于等于1"></node><node CREATED="1593745252664" ID="ID_0192e5eed09f" MODIFIED="1593745252664" TEXT="服务器目前正在执行BGSAVE命令或者BGREWRITEAOF命令，并且哈希表的负载因子大于等于5&amp;lt;br&amp;gt;"></node><node CREATED="1593745252664" ID="ID_99bdead9092c" MODIFIED="1593745252664" TEXT="根据BGSAVE命令或BGREWRITEAOF命令是否正在执行，服务器执行扩展操作所需的负载因子并不相同，这是因为在执行BGSAVE命令或BGREWRITEAOF命令的过程中，Redis需要创建当前服务器进程的子进程，而大多数操作系统都采用写时复制（copy-on-write）技术来优化子进程的使用效率，所以在子进程存在期间，服务器会提高执行扩展操作所需的负载因子，从而尽可能地避免在子进程存在期间进行哈希表扩展操作，这可以避免不必要的内存写入操作，最大限度地节约内存"></node></node></node></node><node CREATED="1593745252664" ID="ID_07d74d96c33a" MODIFIED="1593745252664" TEXT="跳跃表"><node CREATED="1593745252664" ID="ID_c72b8896ac00" MODIFIED="1593745252664" TEXT="定义"><node CREATED="1593745252664" ID="ID_e568abb98761" MODIFIED="1593745252664" TEXT="跳跃表（skiplist）是一种有序数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的"></node><node CREATED="1593745252664" ID="ID_9a95182cbc31" MODIFIED="1593745252664" TEXT="跳跃表支持平均O（logN）、最坏O（N）复杂度的节点查找，还可以通过顺序性操作来批量处理节点"></node><node CREATED="1593745252664" ID="ID_5ecc2d29b750" MODIFIED="1593745252664" TEXT="Redis只在两个地方用到了跳跃表，一个是实现有序集合键，另一个是在集群节点中用作内部数据结构"></node></node><node CREATED="1593745252664" ID="ID_e5889838cfff" MODIFIED="1593745252664" TEXT="zskiplistNode"><node CREATED="1593745252664" ID="ID_0299cd6f66d6" MODIFIED="1593745252664" TEXT="zskiplistNode *backward 后退指针"></node><node CREATED="1593745252664" ID="ID_54b775daa0a0" MODIFIED="1593745252664" TEXT="double score 分值"></node><node CREATED="1593745252664" ID="ID_984956fb930a" MODIFIED="1593745252664" TEXT="robj *obj 成员对象"></node><node CREATED="1593745252664" ID="ID_8ea9eb0bf0e5" MODIFIED="1593745252664" TEXT="level[] 层"><node CREATED="1593745252664" ID="ID_170543e5bcf7" MODIFIED="1593745252664" TEXT="* forward 前进指针"></node><node CREATED="1593745252664" ID="ID_c7c5a3c8d16e" MODIFIED="1593745252664" TEXT="span 跨度"></node></node></node><node CREATED="1593745252664" ID="ID_ec0e75ac9e33" MODIFIED="1593745252664" TEXT="zskiplist"><node CREATED="1593745252664" ID="ID_f0c4a2d2bdf1" MODIFIED="1593745252664" TEXT="zskiplistNode *header,*tail 头尾节点"></node><node CREATED="1593745252664" ID="ID_6b413a997047" MODIFIED="1593745252664" TEXT="length 节点数量"></node><node CREATED="1593745252664" ID="ID_c24db40fffa8" MODIFIED="1593745252664" TEXT="level 最大层数"></node></node><node CREATED="1593745252664" ID="ID_ce243c2264c5" MODIFIED="1593745252664" TEXT="参数解释"><node CREATED="1593745252664" ID="ID_3c434a5a43f9" MODIFIED="1593745252664" TEXT="层"><node CREATED="1593745252664" ID="ID_aef8f3c21cbd" MODIFIED="1593745252664" TEXT="跳跃表节点的level数组可以包含多个元素，每个元素都包含一个指向其他节点的指针，程序可以通过这些层来加快访问其他节点的速度，一般来说，层的数量越多，访问其他节点的速度就越快"></node></node><node CREATED="1593745252664" ID="ID_3efbf5076f65" MODIFIED="1593745252664" TEXT="前进指针"><node CREATED="1593745252664" ID="ID_f7e224e7fc86" MODIFIED="1593745252664" TEXT="每个层都有一个指向表尾方向的前进指针（level[i].forward属性），用于从表头向表尾方向访问节点"></node></node><node CREATED="1593745252664" ID="ID_9c24cd044b1f" MODIFIED="1593745252664" TEXT="跨度"><node CREATED="1593745252664" ID="ID_4fd5cec48904" MODIFIED="1593745252664" TEXT="层的跨度（level[i].span属性）用于记录两个节点之间的距离"><node CREATED="1593745252664" ID="ID_775e475beaff" MODIFIED="1593745252664" TEXT="两个节点之间的跨度越大，它们相距得就越远&amp;lt;br&amp;gt;"></node><node CREATED="1593745252664" ID="ID_225dd99d4c81" MODIFIED="1593745252664" TEXT="指向NULL的所有前进指针的跨度都为0，因为它们没有连向任何节点"></node></node></node><node CREATED="1593745252664" ID="ID_1ddf2a3fdf25" MODIFIED="1593745252664" TEXT="后退指针"><node CREATED="1593745252664" ID="ID_0bf5cf81bb37" MODIFIED="1593745252664" TEXT="节点的后退指针（backward属性）用于从表尾向表头方向访问节点：跟可以一次跳过多个节点的前进指针不同，因为每个节点只有一个后退指针，所以每次只能后退至前一个节点"></node></node><node CREATED="1593745252664" ID="ID_5f9f7fce9f48" MODIFIED="1593745252664" TEXT="分值和成员"><node CREATED="1593745252664" ID="ID_d3d8a6bb383a" MODIFIED="1593745252664" TEXT="节点的分值（score属性）是一个double类型的浮点数，跳跃表中的所有节点都按分值从小到大来排序"></node><node CREATED="1593745252664" ID="ID_b1d2d0ab9c50" MODIFIED="1593745252664" TEXT="节点的成员对象（obj属性）是一个指针，它指向一个字符串对象，而字符串对象则保存着一个SDS值"></node></node></node></node><node CREATED="1593745252664" ID="ID_2c1823f6a159" MODIFIED="1593745252664" TEXT="intset&amp;lt;br&amp;gt;"><node CREATED="1593745252664" ID="ID_be314d1b153d" MODIFIED="1593745252664" TEXT="数据结构"><node CREATED="1593745252664" ID="ID_cef2ecdce189" MODIFIED="1593745252664" TEXT="contents[]"><node CREATED="1593745252664" ID="ID_49297dda1bbf" MODIFIED="1593745252664" TEXT="整数集合的每个元素都是contents数组的一个数组项（item），各个项在数组中按值的大小从小到大有序地排列，并且数组中不包含任何重复项"></node></node><node CREATED="1593745252664" ID="ID_70661c0c6296" MODIFIED="1593745252664" TEXT="length"><node CREATED="1593745252664" ID="ID_184537f187a9" MODIFIED="1593745252664" TEXT="记录了整数集合包含的元素数量，也即是contents数组的长度"></node></node><node CREATED="1593745252664" ID="ID_afe4d640405c" MODIFIED="1593745252664" TEXT="encoding&amp;lt;br&amp;gt;"><node CREATED="1593745252664" ID="ID_381164d31dfa" MODIFIED="1593745252664" TEXT="contents数组的真正类型取决于encoding属性的值"></node></node></node><node CREATED="1593745252664" ID="ID_7be9071864ce" MODIFIED="1593745252664" TEXT="升级"><node CREATED="1593745252664" ID="ID_67cc8c671910" MODIFIED="1593745252664" TEXT="当我们要将一个新元素添加到整数集合里面，并且新元素的类型比整数集合现有所有元素的类型都要长时，整数集合需要先进行升级（upgrade），然后才能将新元素添加到整数集合里面&amp;lt;br&amp;gt;"><node CREATED="1593745252664" ID="ID_977e8bc20e87" MODIFIED="1593745252664" TEXT="根据新元素的类型，扩展整数集合底层数组的空间大小，并为新元素分配空间"></node><node CREATED="1593745252664" ID="ID_9c96d276053e" MODIFIED="1593745252664" TEXT="将底层数组现有的所有元素都转换成与新元素相同的类型，并将类型转换后的元素放置到正确的位上，而且在放置元素的过程中，需要继续维持底层数组的有序性质不变&amp;lt;br&amp;gt;"></node><node CREATED="1593745252664" ID="ID_42e6c6e9bbdb" MODIFIED="1593745252664" TEXT="将新元素添加到底层数组里面&amp;lt;br&amp;gt;"></node></node><node CREATED="1593745252664" ID="ID_26b4d8044248" MODIFIED="1593745252664" TEXT="好处"><node CREATED="1593745252664" ID="ID_abe7130d94a0" MODIFIED="1593745252664" TEXT="提升整数集合的灵活性"><node CREATED="1593745252664" ID="ID_68fcee271a2f" MODIFIED="1593745252664" TEXT="因为整数集合可以通过自动升级底层数组来适应新元素，所以我们可以随意地将int16_t、int32_t或者int64_t类型的整数添加到集合中，而不必担心出现类型错误，这种做法非常灵活&amp;lt;br&amp;gt;"></node></node><node CREATED="1593745252664" ID="ID_aafad3e98b4d" MODIFIED="1593745252664" TEXT="尽可能地节约内存"><node CREATED="1593745252664" ID="ID_3ef0c2f970d1" MODIFIED="1593745252664" TEXT="整数集合现在的做法既可以让集合能同时保存三种不同类型的值，又可以确保升级操作只会在有需要的时候进行，这可以尽量节省内存&amp;lt;br&amp;gt;"></node></node></node><node CREATED="1593745252664" ID="ID_05f912264e5c" MODIFIED="1593745252664" TEXT="整数集合只支持升级操作，不支持降级操作"></node></node></node><node CREATED="1593745252664" ID="ID_0ba65dde25cc" MODIFIED="1593745252664" TEXT="ziplist"><node CREATED="1593745252664" ID="ID_3a371496ce29" MODIFIED="1593745252665" TEXT="当一个列表键只包含少量列表项，并且每个列表项要么就是小整数值，要么就是长度比较短的字符串，那么Redis就会使用压缩列表来做列表键的底层实现"></node><node CREATED="1593745252665" ID="ID_2dfa9b2b2830" MODIFIED="1593745252665" TEXT="压缩列表被用作列表键和哈希键的底层实现之一"></node></node></node><node CREATED="1593745252665" ID="ID_a28e090676b7" MODIFIED="1593745252665" TEXT="sortset 有序集合"><node CREATED="1593745252665" ID="ID_370489de908c" MODIFIED="1593745252665" TEXT="String类型的无序集合，每个元素关联一个double类型的分数，通过分数为集合中的成员排序，double可以重复。通过HashMap和跳跃表实现，HashMap存放成员到score的映射，跳跃表存放所有成员"></node></node><node CREATED="1593745252665" ID="ID_dbd95098ceab" MODIFIED="1593745252665" TEXT="对象"><node CREATED="1593745252665" ID="ID_ecc2b003916d" MODIFIED="1593745252665" TEXT="string"></node><node CREATED="1593745252665" ID="ID_df46f63ad309" MODIFIED="1593745252665" TEXT="list"></node><node CREATED="1593745252665" ID="ID_9e617773b309" MODIFIED="1593745252665" TEXT="hash"></node><node CREATED="1593745252665" ID="ID_d349d16105e6" MODIFIED="1593745252665" TEXT="set"></node><node CREATED="1593745252665" ID="ID_c37de5323eea" MODIFIED="1593745252665" TEXT="zset"></node></node></node><node CREATED="1593745252665" ID="ID_a513c21e3f48" MODIFIED="1593745252665" TEXT="持久化"><node CREATED="1593745252665" ID="ID_59260a3d418e" MODIFIED="1593745252665" TEXT="把内存的数据写到磁盘中，防止服务宕机内存数据丢失"></node><node CREATED="1593745252665" ID="ID_ec8e765aa8a1" MODIFIED="1593745252665" TEXT="方式"><node CREATED="1593745252665" ID="ID_88a9140688cf" MODIFIED="1593745252665" TEXT="RDB（默认）"><node CREATED="1593745252665" ID="ID_7fce8176c66d" MODIFIED="1593745252665" TEXT="生成方式"><node CREATED="1593745252665" ID="ID_5e7ec16c87b3" MODIFIED="1593745252665" TEXT="SAVE"><node CREATED="1593745252665" ID="ID_5fb11c61f169" MODIFIED="1593745252665" TEXT="SAVE命令会阻塞Redis服务器进程，直到RDB文件创建完毕为止，在服务器进程阻塞期间，服务器不能处理任何命令请求"></node></node><node CREATED="1593745252665" ID="ID_eab806f8c09c" MODIFIED="1593745252665" TEXT="BGSAVE"><node CREATED="1593745252665" ID="ID_88c113556e32" MODIFIED="1593745252665" TEXT="BGSAVE命令会派生出一个子进程，然后由子进程负责创建RDB文件，服务器进程（父进程）继续处理命令请求"></node></node></node></node><node CREATED="1593745252665" ID="ID_e45d812cffd9" MODIFIED="1593745252665" TEXT="AOF"><node CREATED="1593745252665" ID="ID_e349b1ad4003" MODIFIED="1593745252665" TEXT="存储结构"><node CREATED="1593745252665" ID="ID_18449bdb2576" MODIFIED="1593745252665" TEXT="内容是redis通讯协议（RESP）格式的命令文本存储"></node></node><node CREATED="1593745252665" ID="ID_4f082f692259" MODIFIED="1593745252665" TEXT="AOF通过保存redis服务器所执行的写命令来记录数据库的数据的"></node><node CREATED="1593745252665" ID="ID_3b5a43d7c876" MODIFIED="1593745252665" TEXT="持久化流程"><node CREATED="1593745252665" ID="ID_e48bf6cee4cc" MODIFIED="1593745252665" TEXT="写入AOF缓存区"><node CREATED="1593745252665" ID="ID_335a7edb1cc2" MODIFIED="1593745252665" TEXT="服务器在执行完一个写命令之后，以协议格式将被执行的命令追加到aof_buf缓冲区的末尾中"></node></node><node CREATED="1593745252665" ID="ID_a66c9b66adf1" MODIFIED="1593745252665" TEXT="考虑是否写入AOF文件"><node CREATED="1593745252665" ID="ID_ba5199ffca21" MODIFIED="1593745252665" TEXT="随后会调用flushAppendOnlyFile函数考虑是否需要将aof_buf缓冲区的内容写入到AOF文件中"></node></node><node CREATED="1593745252665" ID="ID_106c6bdddcdf" MODIFIED="1593745252665" TEXT="考虑是否同步AOF文件"><node CREATED="1593745252665" ID="ID_6629e708c430" MODIFIED="1593745252665" TEXT="最后确定是否将AOF文件内容同步"></node></node></node></node><node CREATED="1593745252665" ID="ID_c5829c17d912" MODIFIED="1593745252665" TEXT="如果两个都配置了，优先加载AOF"><node CREATED="1593745252665" ID="ID_ebc666bcccf2" MODIFIED="1593745252665" TEXT="AOF文件的更新频率通常比RDB文件的更新频率高"></node></node></node><node CREATED="1593745252665" ID="ID_d9995d7232a9" MODIFIED="1593745252665" TEXT="对比"><node CREATED="1593745252665" ID="ID_66184746cedd" MODIFIED="1593745252665" TEXT="RDB"><node CREATED="1593745252665" ID="ID_a167448a4c86" MODIFIED="1593745252665" TEXT="载入时恢复数据快，文件体积小"></node><node CREATED="1593745252665" ID="ID_a17950d64f4a" MODIFIED="1593745252665" TEXT="会一定程度上丢失数据"></node></node><node CREATED="1593745252665" ID="ID_17934d8fca3b" MODIFIED="1593745252665" TEXT="AOF"><node CREATED="1593745252665" ID="ID_d9dd022ccaaf" MODIFIED="1593745252665" TEXT="丢失数据少"></node><node CREATED="1593745252665" ID="ID_bee0a1f0ae9e" MODIFIED="1593745252665" TEXT="恢复数据相对较慢，文件体积大"></node></node></node></node><node CREATED="1593745252665" ID="ID_fa8bedad1327" MODIFIED="1593745252665" TEXT="redis分布式锁是怎么实现的"><node CREATED="1593745252665" ID="ID_d06577e5e7b8" MODIFIED="1593745252665" TEXT="先拿setnx来争抢锁，抢到之后，再用expire给锁加一个过期时间"></node><node CREATED="1593745252665" ID="ID_347ad84e5039" MODIFIED="1593745252665" TEXT="setnx key value"><node CREATED="1593745252665" ID="ID_923109effd8e" MODIFIED="1593745252665" TEXT="将key的值设为value，当且仅当key不存在，若key存在，则不做任何动作"></node></node></node><node CREATED="1593745252665" ID="ID_4d92a61a996e" MODIFIED="1593745252665" TEXT="redis异步队列"><node CREATED="1593745252665" ID="ID_923fc5406c19" MODIFIED="1593745252665" TEXT="使用list结构作为队列，rpush生产消息，lpop消费消息，当lpop没有消息的时候，适当sleep一会"></node></node><node CREATED="1593745252665" ID="ID_16b30585aad2" MODIFIED="1593745252665" TEXT="redis存在的问题"><node CREATED="1593745252665" ID="ID_b8f6e7b4597c" MODIFIED="1593745252665" TEXT="缓存穿透"><node CREATED="1593745252665" ID="ID_1ba37af050bc" MODIFIED="1593745252665" TEXT="原因"><node CREATED="1593745252665" ID="ID_334a0b2e3668" MODIFIED="1593745252665" TEXT="恶意请求故意查询不存在的key，请求量很大，跳过缓存直接查询数据库"></node></node><node CREATED="1593745252665" ID="ID_79f0e8c49e9a" MODIFIED="1593745252665" TEXT="解决方法"><node CREATED="1593745252665" ID="ID_2397f07c70bc" MODIFIED="1593745252665" TEXT="对查询为空的情况也进行缓存，时间设置短一点，或者对该key有insert操作之后清理缓存"></node><node CREATED="1593745252665" ID="ID_63b2b51233d5" MODIFIED="1593745252665" TEXT="使用布隆过滤器过滤一定不存在的key"></node></node></node><node CREATED="1593745252665" ID="ID_830cdd35af73" MODIFIED="1593745252665" TEXT="缓存雪崩"><node CREATED="1593745252665" ID="ID_2b2f43e09290" MODIFIED="1593745252665" TEXT="原因"><node CREATED="1593745252665" ID="ID_f53132f3550a" MODIFIED="1593745252665" TEXT="当缓存服务器重启或者大量缓存集中在某个时间段失效，在失效的时候，会给后端系统带来很大压力"></node></node><node CREATED="1593745252665" ID="ID_79cef22dad9c" MODIFIED="1593745252665" TEXT="解决方法"><node CREATED="1593745252665" ID="ID_83bbdb9e189c" MODIFIED="1593745252665" TEXT="保证缓存层服务高可用性"></node><node CREATED="1593745252665" ID="ID_955fa15f8ff7" MODIFIED="1593745252665" TEXT="使用消息队列为后端限流"></node><node CREATED="1593745252665" ID="ID_420d9dcbefb8" MODIFIED="1593745252665" TEXT="错开键的过期时间"></node></node></node></node><node CREATED="1593745252665" ID="ID_7ca68f4ac76d" MODIFIED="1593745252665" TEXT="主从复制相关"><node CREATED="1593745252665" ID="ID_28b11d5e7616" MODIFIED="1593745252665" LINK="https://www.cnblogs.com/kevingrace/p/5685332.html"></node><node CREATED="1593745252665" ID="ID_a02fee4f564e" MODIFIED="1593745252665" TEXT="前置工作"><node CREATED="1593745252665" ID="ID_45b19b04e0ee" MODIFIED="1593745252665" TEXT="从服务器设置主服务器的IP和端口"></node><node CREATED="1593745252665" ID="ID_a34dee8f21ad" MODIFIED="1593745252665" TEXT="建立与主服务器的Socket连接"></node><node CREATED="1593745252665" ID="ID_3e600a2f44e3" MODIFIED="1593745252665" TEXT="发送PING命令"></node><node CREATED="1593745252665" ID="ID_12694af38746" MODIFIED="1593745252665" TEXT="身份验证"></node><node CREATED="1593745252665" ID="ID_c55f7f9bda8d" MODIFIED="1593745252665" TEXT="从服务器给主服务器发送端口的信息，主服务器记录监听的端口"></node></node><node CREATED="1593745252665" ID="ID_5770a0325fea" MODIFIED="1593745252665" TEXT="完整重同步"><node CREATED="1593745252665" ID="ID_6418c8216340" MODIFIED="1593745252665" TEXT="从服务器向主服务器发送PSYNC命令"></node><node CREATED="1593745252665" ID="ID_beb691d3fbe9" MODIFIED="1593745252665" TEXT="收到PSYNC命令的主服务器执行BGSAVE命令，在后台生成一个RDB文件。并用一个缓存区来记录从现在开始执行的所有写命令"></node><node CREATED="1593745252665" ID="ID_150586a46b35" MODIFIED="1593745252665" TEXT="当主服务器的BGSAVE命令执行完后，将生成的RDB文件发送给从服务器，从服务器接收和载入RBD文件将自己的数据库状态更新至与主服务器执行BGSAVE命令时的状态"></node><node CREATED="1593745252665" ID="ID_9dff39a2c229" MODIFIED="1593745252665" TEXT="主服务器将所有缓冲区的写命令发送给从服务器，从服务器执行这些写命令，达到数据最终一致性"></node></node><node CREATED="1593745252665" ID="ID_e70f0284f471" MODIFIED="1593745252665" TEXT="部分重同步"><node CREATED="1593745252665" ID="ID_2e00909976f1" MODIFIED="1593745252665" TEXT="模块"><node CREATED="1593745252665" ID="ID_422ffb736bbd" MODIFIED="1593745252665" TEXT="主从服务器的复制偏移量"><node CREATED="1593745252665" ID="ID_a3df4315d44c" MODIFIED="1593745252665" TEXT="执行复制的双方都会分别维护一个复制偏移量"></node><node CREATED="1593745252665" ID="ID_2200cdcd0313" MODIFIED="1593745252665" TEXT="主服务器每次传播N个字节，就将自己的复制偏移量加N,从服务器同理"></node><node CREATED="1593745252665" ID="ID_8f1db106a9c8" MODIFIED="1593745252665" TEXT="通过对比主从复制的偏移量，判断主从服务器数据是否一致"></node></node><node CREATED="1593745252665" ID="ID_00771e0c4603" MODIFIED="1593745252665" TEXT="主服务器的复制积压缓冲区"><node CREATED="1593745252665" ID="ID_40a18efe06a1" MODIFIED="1593745252665" TEXT="主服务器进行命令传播时，不仅会将命令发送给所有从服务器，还会将写命令入队到复制积压缓冲区里面。"></node><node CREATED="1593745252665" ID="ID_5d9013366c62" MODIFIED="1593745252665" TEXT="如果复制积压缓冲区存在丢失的偏移量的数据，那就执行部分重同步，否则，执行完整重同步"></node></node><node CREATED="1593745252665" ID="ID_75fbd3305ec0" MODIFIED="1593745252665" TEXT="服务器运行的ID(run ID)"><node CREATED="1593745252665" ID="ID_7f87e84dfca7" MODIFIED="1593745252665" TEXT="服务器run ID用来比对ID是否相同，判断从服务器断线之前复制的主服务器和当前连接的主服务器是否是同一台服务器，不是则进行完整重同步"></node></node></node></node></node><node CREATED="1593745252665" ID="ID_164f1adf4a27" MODIFIED="1593745252665" TEXT="心跳检测"><node CREATED="1593745252665" ID="ID_c2cb6a475d93" MODIFIED="1593745252665" TEXT="在命令传播阶段，从服务器默认会以每秒一次的频率，向主服务器发送命令"><node CREATED="1593745252665" ID="ID_59c83d44439b" MODIFIED="1593745252665" TEXT="REPLCONF ACK &amp;lt;replication_offset&amp;gt;"></node><node CREATED="1593745252665" ID="ID_97bbe8534c03" MODIFIED="1593745252665" TEXT="replication_offset是从服务器当前的复制偏移量"><node CREATED="1593745252665" ID="ID_fd1891453deb" MODIFIED="1593745252665" TEXT="检测主从服务器的网络连接状态"></node><node CREATED="1593745252665" ID="ID_f51ab5014b51" MODIFIED="1593745252665" TEXT="辅助实现min-slaves选项"></node><node CREATED="1593745252665" ID="ID_2fbabc11e375" MODIFIED="1593745252665" TEXT="检测命令丢失"></node></node></node></node><node CREATED="1593745252665" ID="ID_be4beddab4f5" MODIFIED="1593745252665" TEXT="哨兵机制"><node CREATED="1593745252665" ID="ID_b4ce190518cd" MODIFIED="1593745252665" TEXT="哨兵的含义就是监控redis系统的运行状态"></node><node CREATED="1593745252665" ID="ID_d7e14569313f" MODIFIED="1593745252665" TEXT="监控所有节点数据库是否在正常运行。"></node><node CREATED="1593745252665" ID="ID_0321f7e5b976" MODIFIED="1593745252665" TEXT="master数据库出现故障时，可以自动通过投票机制，从slave节点中选举新的master，实现将从数据库转换为主数据库的自动切换"></node></node><node CREATED="1593745252665" ID="ID_ee0b4313a954" MODIFIED="1593745252665" TEXT="redis高并发和快速的原因"><node CREATED="1593745252665" ID="ID_1e1d94924875" MODIFIED="1593745252665" TEXT="redis是基于内存的，内存的读写速度非常快"></node><node CREATED="1593745252665" ID="ID_2f7c1f3dc21f" MODIFIED="1593745252665" TEXT="redis是单线程的，省去了很多上下文切换线程的时间"></node><node CREATED="1593745252665" ID="ID_1e705c12ba80" MODIFIED="1593745252665" TEXT="redis使用多路复用技术，可以处理并发的连接。"></node></node><node CREATED="1593745252665" ID="ID_2d573cb19094" MODIFIED="1593745252665" TEXT="redis过期键处理"><node CREATED="1593745252665" ID="ID_b59b15f57f37" MODIFIED="1593745252665" TEXT="判断键是否过期"><node CREATED="1593745252665" ID="ID_28323eb75cde" MODIFIED="1593745252665" TEXT="在redis中维护一个expires字典，保存数据库中所有设置了过期时间的键的过期时间。通过key去字典中获取key的过期毫秒时间戳，再减去当前时间戳，得到剩余生存时间"></node></node><node CREATED="1593745252665" ID="ID_e9e86c3b2264" MODIFIED="1593745252665" TEXT="过期键删除策略"><node CREATED="1593745252665" ID="ID_823342eb08d5" MODIFIED="1593745252665" TEXT="惰性删除策略(被动)"><node CREATED="1593745252665" ID="ID_013d991bba60" MODIFIED="1593745252665" TEXT="程序在取出键时才对key进行过期检查，若过期则删除，否则照常执行"><node CREATED="1593745252665" ID="ID_c8bb8a65fb08" MODIFIED="1593745252665" TEXT="优点"><node CREATED="1593745252665" ID="ID_482c09023323" MODIFIED="1593745252665" TEXT="对CPU时间来说是最友好的：程序只会在取出键时才对键进行过期检查，这可以保证删除过期键的操作只会在非做不可的情况下进行，并且删除的目标仅限于当前处理的键，这个策略不会在删除其他无关的过期键上花费任何CPU时间&amp;lt;br&amp;gt;"></node></node><node CREATED="1593745252665" ID="ID_d0827ccb0b29" MODIFIED="1593745252665" TEXT="缺点"><node CREATED="1593745252665" ID="ID_eff95e609bb7" MODIFIED="1593745252665" TEXT="对内存是最不友好的：如果一个键已经过期，而这个键又仍然保留在数据库中，那么只要这个过期键不被删除，它所占用的内存就不会释放"></node></node></node></node><node CREATED="1593745252665" ID="ID_888676b4239f" MODIFIED="1593745252665" TEXT="定期删除策略(主动)"><node CREATED="1593745252665" ID="ID_a0c08a51fd0d" MODIFIED="1593745252665" TEXT="每隔一段时间执行一次随机删除过期键的操作，并通过限制删除操作执行的时常和频率来减少删除操作对cpu时间的影响"></node><node CREATED="1593745252665" ID="ID_359ae377d111" MODIFIED="1593745252665" TEXT="通过定期删除过期键，定期删除策略有效地减少了因为过期键而带来的内存浪费"></node></node></node><node CREATED="1593745252665" ID="ID_2d69583135e6" MODIFIED="1593745252665" TEXT="内存淘汰机制"><node CREATED="1593745252665" ID="ID_c3cb9e6bb7c9" MODIFIED="1593745252665" TEXT="定期删除漏掉很多过期key，且没及时执行惰性删除，大量过期key堆积在内存，导致redis内存块耗尽"></node><node CREATED="1593745252665" ID="ID_b52ab99c1ede" MODIFIED="1593745252665" TEXT="volatile-lru"><node CREATED="1593745252665" ID="ID_cc3fe8591180" MODIFIED="1593745252665" TEXT="从已设置过期时间的数据集中挑选最近最少使用的数据淘汰"></node></node><node CREATED="1593745252665" ID="ID_ee39c9a8f293" MODIFIED="1593745252665" TEXT="volatile-ttl"><node CREATED="1593745252665" ID="ID_ffd11aa380df" MODIFIED="1593745252665" TEXT="从已设置过期时间的数据集中挑选将要过期的数据淘汰"></node></node><node CREATED="1593745252665" ID="ID_1d4b5328d6e6" MODIFIED="1593745252665" TEXT="volatile-random"><node CREATED="1593745252665" ID="ID_343dcde83ebd" MODIFIED="1593745252665" TEXT="从已设置过期时间的数据集中任意选择数据淘汰"></node></node><node CREATED="1593745252665" ID="ID_8b720a6a81bf" MODIFIED="1593745252665" TEXT="allkeys-lru"><node CREATED="1593745252665" ID="ID_ac3aa77b3bdf" MODIFIED="1593745252665" TEXT="从所有数据集中挑选最近最少使用的数据淘汰"></node></node><node CREATED="1593745252665" ID="ID_c122507d7c69" MODIFIED="1593745252665" TEXT="allkeys-random"><node CREATED="1593745252665" ID="ID_5c2b5bfe9861" MODIFIED="1593745252665" TEXT="从所有数据集中任意选择数据进行淘汰"></node></node><node CREATED="1593745252665" ID="ID_a601644e8612" MODIFIED="1593745252665" TEXT="noeviction"><node CREATED="1593745252665" ID="ID_9d9c1712d9bb" MODIFIED="1593745252665" TEXT="禁止驱逐数据"></node></node><node CREATED="1593745252665" ID="ID_5976fa417dc8" MODIFIED="1593745252665" TEXT="一般场景"><node CREATED="1593745252665" ID="ID_fe8b8682d1d7" MODIFIED="1593745252665" TEXT="使用redis缓存数据时，为了提高缓存命中率，需要保证缓存数据都是热点数据。即将内存最大使用量设置为热点数据占用的内存量，然后启用allkeys-lru 淘汰策略，将最近最少使用的数据淘汰"></node></node></node><node CREATED="1593745252665" ID="ID_733165df3d60" MODIFIED="1593745252665" TEXT="持久化过程对过期键的处理"><node CREATED="1593745252665" ID="ID_2afb12bb1165" MODIFIED="1593745252665" TEXT="RDB"><node CREATED="1593745252665" ID="ID_df408d59dcb1" MODIFIED="1593745252665" TEXT="执行SAVE或者BGSAVE命令创建出的RDB文件，程序会对数据库中的过期键检查，已过期的键不会保存在RDB文件中"></node><node CREATED="1593745252665" ID="ID_d58ad5159bc7" MODIFIED="1593745252665" TEXT="载入RDB文件时，程序同样会对RDB文件中的键进行检查，过期的键会被忽略"></node></node><node CREATED="1593745252665" ID="ID_3c47a61b1dab" MODIFIED="1593745252665" TEXT="AOF"><node CREATED="1593745252665" ID="ID_dafe5b75a157" MODIFIED="1593745252665" TEXT="如果数据库的键已过期，但没被删除，AOF会保留该键，当过期的键被删除以后，会追加一条DEL命令来显示记录删除信息"></node><node CREATED="1593745252665" ID="ID_85730f471370" MODIFIED="1593745252665" TEXT="重写AOF文件时，程序会对AOF文件中的键进行检查，过期的键会被忽略"></node></node><node CREATED="1593745252665" ID="ID_764055a3168f" MODIFIED="1593745252665" TEXT="主从复制"><node CREATED="1593745252665" ID="ID_4973817fb37c" MODIFIED="1593745252665" TEXT="从在读到过期键的时候，不会删除，而是返回该值，只有在主显示删除改过期键时通知从才会删除该键，这样保证主从一致性"></node></node></node></node><node CREATED="1593745252665" ID="ID_4d3a3c2f2aef" MODIFIED="1593745252665" TEXT="事务"><node CREATED="1593745252665" ID="ID_3ef5a9206682" MODIFIED="1593745252665" TEXT="Redis会将EXEC命令前的命令放入一个队列，当遇到EXEC时批量执行队列中的命令，但是Redis的事务不支持回滚"></node></node><node CREATED="1593745252665" ID="ID_c136281d3d89" MODIFIED="1593745252665" TEXT="架构模式"><node CREATED="1593745252665" ID="ID_7eef446b8269" MODIFIED="1593745252665" TEXT="单机"><node CREATED="1593745252665" ID="ID_249a01fd9679" MODIFIED="1593745252665" TEXT="特点"><node CREATED="1593745252665" ID="ID_9bc747bda14c" MODIFIED="1593745252665" TEXT="简单"></node></node><node CREATED="1593745252665" ID="ID_25c2330b9098" MODIFIED="1593745252665" TEXT="问题"><node CREATED="1593745252665" ID="ID_fe6de61547f1" MODIFIED="1593745252665" TEXT="内存容量有限"></node><node CREATED="1593745252665" ID="ID_a60191d5db2b" MODIFIED="1593745252665" TEXT="处理能力有限"></node><node CREATED="1593745252665" ID="ID_1da3269693b7" MODIFIED="1593745252665" TEXT="无法高可用"></node></node></node><node CREATED="1593745252665" ID="ID_3c11bcd7c7c0" MODIFIED="1593745252665" TEXT="主从复制"><node CREATED="1593745252665" ID="ID_60cfd1b42630" MODIFIED="1593745252665" TEXT="特点"><node CREATED="1593745252665" ID="ID_3de3460df57a" MODIFIED="1593745252665" TEXT="数据相同，主服务器会把数据同步到从服务器"></node><node CREATED="1593745252665" ID="ID_8f6158ab52df" MODIFIED="1593745252665" TEXT="主服务器用来写，从服务器用来读"></node></node><node CREATED="1593745252665" ID="ID_1c0a28e8ce04" MODIFIED="1593745252665" TEXT="问题"><node CREATED="1593745252665" ID="ID_71b967ab717d" MODIFIED="1593745252665" TEXT="无法保证高可用"></node><node CREATED="1593745252665" ID="ID_1d28ab0fe42f" MODIFIED="1593745252665" TEXT="没有解决master写的压力"></node></node></node><node CREATED="1593745252665" ID="ID_096aec124945" MODIFIED="1593745252665" TEXT="哨兵"><node CREATED="1593745252665" ID="ID_31a49163feac" MODIFIED="1593745252665" TEXT="特征"><node CREATED="1593745252665" ID="ID_8998c97c1e36" MODIFIED="1593745252665" TEXT="监控 主服务器和从服务器是否运行正常"></node><node CREATED="1593745252665" ID="ID_a104a83e83ab" MODIFIED="1593745252665" TEXT="提醒 当被监控的redis服务器发现问题，可以通过api向管理员或者其他应用发送通知"></node><node CREATED="1593745252665" ID="ID_8d5b71c21a09" MODIFIED="1593745252665" TEXT="自动故障迁移，将从服务器升级为主服务器"></node></node><node CREATED="1593745252665" ID="ID_a50447a668f3" MODIFIED="1593745252665" TEXT="特点"><node CREATED="1593745252665" ID="ID_c257f8d211b7" MODIFIED="1593745252665" TEXT="保证高可用"></node><node CREATED="1593745252665" ID="ID_20f4fcb94709" MODIFIED="1593745252665" TEXT="监控各个节点"></node><node CREATED="1593745252665" ID="ID_d033c99ce819" MODIFIED="1593745252665" TEXT="自动保障迁移"></node></node><node CREATED="1593745252665" ID="ID_34e7a8aa0749" MODIFIED="1593745252665" TEXT="问题"><node CREATED="1593745252665" ID="ID_f6546daebbc4" MODIFIED="1593745252665" TEXT="没有解决master写的压力"></node><node CREATED="1593745252665" ID="ID_cb3dad701f19" MODIFIED="1593745252665" TEXT="切换主从模式需要时间丢数据"></node></node></node><node CREATED="1593745252665" ID="ID_8c8408de476d" MODIFIED="1593745252665" TEXT="集群"><node CREATED="1593745252665" ID="ID_8354709d126d" MODIFIED="1593745252665" TEXT="代理集群"></node><node CREATED="1593745252665" ID="ID_efd940048779" MODIFIED="1593745252665" TEXT="直连型集群"><node CREATED="1593745252665" ID="ID_f8d0e7b1955f" MODIFIED="1593745252665" TEXT="无中心结构，每个节点保存数据和整个集群状态，每个节点都和其他所有节点连接"></node><node CREATED="1593745252665" ID="ID_0c94fcbcf7b3" MODIFIED="1593745252665" TEXT="特点"><node CREATED="1593745252665" ID="ID_a30b9298fc26" MODIFIED="1593745252665" TEXT="所有的redis节点互联"></node><node CREATED="1593745252665" ID="ID_6b2f16963acf" MODIFIED="1593745252665" TEXT="节点的fail是通过集群中超过半数的节点检测失效时才生效"></node><node CREATED="1593745252665" ID="ID_8c74e3216525" MODIFIED="1593745252665" TEXT="客户端与redis节点直连，不需要中间proxy层"></node></node></node></node></node></node><node CREATED="1593745252665" ID="ID_91564cfa8abd" POSITION="right" MODIFIED="1593745252665" TEXT="分布式"><node CREATED="1593745252665" ID="ID_3e3d968575a0" MODIFIED="1593745252665" TEXT="zookeeper"><node CREATED="1593745252665" ID="ID_5f876c321add" MODIFIED="1593745252665" TEXT="主备模式"><node CREATED="1593745252665" ID="ID_4993da12a67c" MODIFIED="1593745252665" TEXT="所有客户端写入数据都是写入到主进程(Leader)，然后，由Leader复制到备份进程(Follower)中，从而保证数据一致性"></node></node><node CREATED="1593745252665" ID="ID_d6e37210abee" MODIFIED="1593745252665" TEXT="zab协议"><node CREATED="1593745252665" ID="ID_b8793c425a52" MODIFIED="1593745252665" TEXT="一种一致性协议"></node><node CREATED="1593745252665" ID="ID_04e02fa2d7bd" MODIFIED="1593745252665" TEXT="为分布式协调服务zookeeper专门设计的一种支持崩溃恢复和消息广播协议"></node><node CREATED="1593745252665" ID="ID_35538b13d841" MODIFIED="1593745252665" TEXT="消息广播(Leader正常)"><node CREATED="1593745252665" ID="ID_5c3c7db6729a" MODIFIED="1593745252665" TEXT="对于客户端发送的写请求，全部由Leader接收，Leader将请求封装成一个事务Proposal，将其发送给所有Follower，然后根据所有Follower的反馈，如果超过半数成功响应，则执行commit操作(先提交自己，再发送commit给所有Follower)"></node><node CREATED="1593745252665" ID="ID_843db08212ac" MODIFIED="1593745252665" TEXT="细节"><node CREATED="1593745252665" ID="ID_0190fe71335a" MODIFIED="1593745252665" TEXT="Leader在收到客户端请求之后，会将这个请求封装成一个事务，并给这个事务分配一个全局递增的唯一ID，称为事务ID，zab协议需要保证事务的顺序，因此将每个事务按照事务ID先排序再处理"></node><node CREATED="1593745252665" ID="ID_2d10bd3831c4" MODIFIED="1593745252665" TEXT="再Leader和Follower之间还有一个消息队列，用来解耦他们之间的耦合，接触同步阻塞"></node><node CREATED="1593745252665" ID="ID_4c42562bf2f0" MODIFIED="1593745252665" TEXT="zookeeper集群为保证任何所有进程能够有序的顺序执行，只能是Leader服务器接受写请求，即使是Follower服务器接受到客户端的请求，也会转发到Leader服务器进行处理"></node></node></node><node CREATED="1593745252665" ID="ID_2445f07d8a5e" MODIFIED="1593745252665" TEXT="崩溃恢复(Leader崩溃)"><node CREATED="1593745252665" ID="ID_9fa1e0998d11" MODIFIED="1593745252665" TEXT="两个原则"><node CREATED="1593745252665" ID="ID_cfd604924daa" MODIFIED="1593745252665" TEXT="zab协议确保那些已经在Leader提交的事务最终会被所有服务器提交"><node CREATED="1593745252665" ID="ID_666fb8ba735c" MODIFIED="1593745252665" TEXT="新的 leader 与 follower 建立先进先出的队列， 先将自身有而 follower 没有的 proposal 发送给 follower，再将这些 proposal 的 COMMIT 命令发送给 follower，以保证所有的 follower 都保存了所有的 proposal、所有的 follower 都处理了所有的消息&amp;nbsp;"></node></node><node CREATED="1593745252665" ID="ID_7aaece4af59a" MODIFIED="1593745252665" TEXT="zab协议确保丢弃那些只在Leader 提出/复制，但没有提交的事务"></node></node><node CREATED="1593745252665" ID="ID_12a809a70431" MODIFIED="1593745252665" TEXT="实现"><node CREATED="1593745252665" ID="ID_57592b2b8ba4" MODIFIED="1593745252665" TEXT="通过选举算法(选举出来的Leader服务器拥有集群中事务ID最大的服务器)，保证这个新选举出来的Leader一定具有所有已经提交的提案"></node></node><node CREATED="1593745252665" ID="ID_eeb122f21bd2" MODIFIED="1593745252665" TEXT="数据同步"><node CREATED="1593745252665" ID="ID_77bb50c1a91d" MODIFIED="1593745252665" TEXT="奔溃恢复之后，需要在正式工作之前(接受客户端请求)，Leader服务器首先确认事务是否都已经被过半的Follower提交了，即是否完成了数据同步。"></node><node CREATED="1593745252665" ID="ID_77bb50c1a91d" MODIFIED="1593745252665" TEXT="奔溃恢复之后，需要在正式工作之前(接受客户端请求)，Leader服务器首先确认事务是否都已经被过半的Follower提交了，即是否完成了数据同步。"></node><node CREATED="1593745252665" ID="ID_b0df152a2ce0" MODIFIED="1593745252665" TEXT="当完成Leader选举后，进行故障恢复的第二步就是数据同步： Leader服务器会为每一个Follower服务器准备一个队列，并将那些没有被各个Follower服务器同步的事务以Proposal的形式逐条发给各个Follower服务器，并在每一个Proposal后都紧跟一个commit消息，表示该事务已经被提交，当follower服务器将所有尚未同步的事务proposal都从leader服务器同步过来并成功应用到本地后，leader服务器就会将该follower加入到真正可用的follower列表中。（新选举周期，epoch已经更新了） "></node></node></node></node><node CREATED="1593745252665" ID="ID_0805c41871e5" MODIFIED="1593745252665" TEXT="节点类型"><node CREATED="1593745252665" ID="ID_d7cacaafb93a" MODIFIED="1593745252665" TEXT="持久节点"><node CREATED="1593745252665" ID="ID_dbb3e985d529" MODIFIED="1593745252665" TEXT="节点创建后，一直存在，直到主动删除了该节点"></node></node><node CREATED="1593745252665" ID="ID_5b7a02cff4e9" MODIFIED="1593745252665" TEXT="临时节点"><node CREATED="1593745252665" ID="ID_7a63315fa9e9" MODIFIED="1593745252665" TEXT="生命周期和客户端会话绑定，一旦客户端会话失效，这个节点就会自动删除"></node></node><node CREATED="1593745252665" ID="ID_64c8fd24f0c5" MODIFIED="1593745252665" TEXT="序列节点"><node CREATED="1593745252665" ID="ID_ac992793abdb" MODIFIED="1593745252665" TEXT="多个线程创建同一个顺序节点时，每个线程会得到一个带有编号的节点，节点编号是递增不重复的"></node></node></node><node CREATED="1593745252665" ID="ID_654a4cd7a001" MODIFIED="1593745252665" TEXT="脑裂"><node CREATED="1593745252665" ID="ID_9ea1988645ef" MODIFIED="1593745252665" TEXT="例如两个机房内的实例组成一个集群，如果两个机房间的网络出现问题，但机房内部通信没有问题，可能导致两个机房都选举出一个leader，一旦网络恢复，就存在脑裂问题"></node><node CREATED="1593745252666" ID="ID_02823126e530" MODIFIED="1593745252666" TEXT="由于zk使用的是过半选举机制，所以不会出现脑裂问题"></node></node></node><node CREATED="1593745252666" ID="ID_9b0d62cfcd6f" MODIFIED="1593745252666" TEXT="dubbo"><node CREATED="1593745252666" ID="ID_e124dbc0eaa1" MODIFIED="1593745252666" TEXT="负载均衡"><node CREATED="1593745252666" ID="ID_f306b68a8ffc" MODIFIED="1593745252666" TEXT="随机，按照权重设置随机概率，可以动态调整权重"></node><node CREATED="1593745252666" ID="ID_5a3cc3531920" MODIFIED="1593745252666" TEXT="轮询，按公约后的权重设置轮询比率"></node><node CREATED="1593745252666" ID="ID_54491b676ad7" MODIFIED="1593745252666" TEXT="最少活跃数，相同活跃数的随机，活跃数指调用前后计数差"></node><node CREATED="1593745252666" ID="ID_55f657241162" MODIFIED="1593745252666" TEXT="一致性哈希"></node></node></node></node><node CREATED="1593745252666" ID="ID_05b4e549e6f1" POSITION="right" MODIFIED="1593745252666" TEXT="其他"><node CREATED="1593745252666" ID="ID_4860e7ea6bfa" MODIFIED="1593745252666" TEXT="抽象类和接口的区别"><node CREATED="1593745252666" ID="ID_1f631b6cf572" MODIFIED="1593745252666" TEXT="设计层面上，抽象类提供了 IS-A关系，接口是LIKE-A关系"></node><node CREATED="1593745252666" ID="ID_6e90a3ccbe60" MODIFIED="1593745252666" TEXT="使用上，一个类可以实现多个接口，但是不能继承多个抽象类"></node><node CREATED="1593745252666" ID="ID_2e9f404c576d" MODIFIED="1593745252666" TEXT="接口的字段只能是static和final的，抽象类的字段没有限制"></node><node CREATED="1593745252666" ID="ID_720248b7f32b" MODIFIED="1593745252666" TEXT="接口的方法只能是public的，抽象类的方法可以有多种访问权限"></node><node CREATED="1593745252666" ID="ID_9e3c2173694c" MODIFIED="1593745252666" TEXT="java8之前接口的方法不能有方法体，java8之后可以有具体实现"></node></node><node CREATED="1593745252666" ID="ID_b7b519cf8ee6" MODIFIED="1593745252666" TEXT="IO模型"><node CREATED="1593745252666" ID="ID_1b572747a7c9" MODIFIED="1593745252666" TEXT="BIO（阻塞IO）"><node CREATED="1593745252666" ID="ID_9ad0168c7f43" MODIFIED="1593745252666" TEXT="一个连接一个线程"></node><node CREATED="1593745252666" ID="ID_ab5bad3e6993" MODIFIED="1593745252666" TEXT="现在服务端启动ServerSocket,然后在客户端启动Socket对服务端进行通信，默认情况下服务端需要对每个请求建立一堆线程等待请求，而客户端发送请求后，先咨询服务端是否有线程相应，如果没有则会一直等待或者遭到拒绝请求，如果有的话，客户端线程会等待请求结束后才继续执行"></node></node><node CREATED="1593745252666" ID="ID_25e0daa91a29" MODIFIED="1593745252666" TEXT="NIO（非阻塞IO）"><node CREATED="1593745252666" ID="ID_44a9cf2c3a0f" MODIFIED="1593745252666" TEXT="一个请求一个线程"><node CREATED="1593745252666" ID="ID_f4a44dfef2c7" MODIFIED="1593745252666" TEXT="核心"><node CREATED="1593745252666" ID="ID_345a861a1ee1" MODIFIED="1593745252666" TEXT="Channel"></node><node CREATED="1593745252666" ID="ID_38e306eeb761" MODIFIED="1593745252666" TEXT="Buffer"></node><node CREATED="1593745252666" ID="ID_9a277350eec9" MODIFIED="1593745252666" TEXT="Selector"></node></node></node><node CREATED="1593745252666" ID="ID_ee178ae9cb9e" MODIFIED="1593745252666" TEXT="NIO基于Reactor，不是一个连接对应一个处理线程，而是一个有效的请求，对应一个线程，当连接没有数据时，是没有工作线程来处理的。NIO最重要的地方是当一个连接创建后，不需要对应一个线程，这个连接会被注册到多路复用器上，所有的连接只需要一个线程就可以，当这个线程中的多路复用器进行轮询时，发现连接上有请求的话，才开启一个线程进行处理。"></node><node CREATED="1593745252666" ID="ID_fe1469706bc3" MODIFIED="1593745252666" TEXT="Reactor线程模型"><node CREATED="1593745252666" ID="ID_564ff111c0f2" MODIFIED="1593745252666" TEXT="Reactor 模式是处理并发 I/O 比较常见的一种模式，用于同步 I/O，中心思想是将所有要处理的IO事件注册到一个中心 I/O 多路复用器上，同时主线程/进程阻塞在多路复用器上；一旦有 I/O 事件到来或是准备就绪(文件描述符或 socket 可读、写)，多路复用器返回并将事先注册的相应 I/O 事件分发到对应的处理器中&amp;nbsp;"></node></node><node CREATED="1593745252666" ID="ID_aedd345f9d04" MODIFIED="1593745252666" TEXT="NIO服务端流程"><node CREATED="1593745252666" ID="ID_3e7348cad1d9" MODIFIED="1593745252666" TEXT="创建ServerSocketChannel,绑定一个端口，并设置为非阻塞"></node><node CREATED="1593745252666" ID="ID_8f344629d01b" MODIFIED="1593745252666" TEXT="生成一个selector对象"></node><node CREATED="1593745252666" ID="ID_6909fe7c9eb6" MODIFIED="1593745252666" TEXT="将ServerSocketChannel注册到selector上，并设置关心的事件为 OP_ACCEPT"></node><node CREATED="1593745252666" ID="ID_0d302658d55e" MODIFIED="1593745252666" TEXT="循环等待客户端连接"></node><node CREATED="1593745252666" ID="ID_ac27dbbe91b8" MODIFIED="1593745252666" TEXT="如果selector对象调用select()没有事件发送，则返回"></node><node CREATED="1593745252666" ID="ID_92411629876e" MODIFIED="1593745252666" TEXT="如果有事件发生，就获取到相关的 selectionKey集合，通过集合里的selectionKeys反向获取通道&amp;lt;br&amp;gt;"></node><node CREATED="1593745252666" ID="ID_033d9c1ee946" MODIFIED="1593745252666" TEXT="如果是 OP_ACCEPT事件， 调用serverSocketChannel.accept() 获得socketChannel,将该channel设置为非阻塞，并注册到selector对象中&amp;lt;br&amp;gt;"></node><node CREATED="1593745252666" ID="ID_2518588725c2" MODIFIED="1593745252666" TEXT="如果是OP_READ事件，通过selectionKeys获取对应通道，并读取他的buffer&amp;lt;br&amp;gt;"></node><node CREATED="1593745252666" ID="ID_7a3e327e03d2" MODIFIED="1593745252666" TEXT="移除该 selectionKeys,防止多线程情况下重复处理"></node></node></node><node CREATED="1593745252666" ID="ID_6b986025bac2" MODIFIED="1593745252666" TEXT="AIO（异步非阻塞IO）"><node CREATED="1593745252666" ID="ID_943a4573fb09" MODIFIED="1593745252666" TEXT="一个有效请求一个线程"></node><node CREATED="1593745252666" ID="ID_bd24dfab8820" MODIFIED="1593745252666" TEXT="AIO需要一个连接注册读写事件和回调方法，当进行读写操作时，只须直接调用API的read或write方法即可。这两种方法均为异步的，对于读操作而言，当有流可读取时，操作系统会将可读的流传入read方法的缓冲区，并通知应用程序；对于写操作而言，当操作系统将write方法传递的流写入完毕时，操作系统主动通知应用程序。 即可以理解为，read/write方法都是异步的，完成后会主动调用回调函数"></node></node><node CREATED="1593745252666" ID="ID_f4e5d7923782" MODIFIED="1593745252666" TEXT="Netty简易"><node CREATED="1593745252666" ID="ID_32e7846b3322" MODIFIED="1593745252666" TEXT="BossGroup维护一个selector，这个selector只处理client的accept事件"></node><node CREATED="1593745252666" ID="ID_0c688fad1728" MODIFIED="1593745252666" TEXT="处理对应的accept事件，获得对应的socketChannel，封装成NIOSocketChannel，注册到WorkerGroup,并进行维护&amp;lt;br&amp;gt;"></node><node CREATED="1593745252666" ID="ID_c85cb46092cd" MODIFIED="1593745252666" TEXT="当worker线程接受到读写事件，就将这事件交给handler处理"></node></node></node><node CREATED="1593745252666" ID="ID_8d17ba6ce51a" MODIFIED="1593745252666" TEXT="单例模式"><node CREATED="1593745252666" ID="ID_08400161003c" MODIFIED="1593745252666" TEXT="单例模式可以保证系统中一个类只有一个实例"><node CREATED="1593745252666" ID="ID_2e13c0aaabba" MODIFIED="1593745252666" TEXT="单例模式只能有一个实例"></node><node CREATED="1593745252666" ID="ID_85648705b4ad" MODIFIED="1593745252666" TEXT="单例模式类必须自己创建自己的唯一实例"></node><node CREATED="1593745252666" ID="ID_b1a6c04bf212" MODIFIED="1593745252666" TEXT="单例模式类必须给所有其他对象提供这一实例"></node></node><node CREATED="1593745252666" ID="ID_8b762eed805b" MODIFIED="1593745252666" TEXT="分类"><node CREATED="1593745252666" ID="ID_df39fee4decd" MODIFIED="1593745252666" TEXT="饿汉式"><node CREATED="1593745252666" ID="ID_d6af3f3d77ad" MODIFIED="1593745252666" TEXT="优点"><node CREATED="1593745252666" ID="ID_57893325beca" MODIFIED="1593745252666" TEXT="实现简单，不存在多线程同步问题，避免了synchronized所造成的性能问题，是线程安全的(JVM保证线程安全)"><node CREATED="1593745252666" ID="ID_8563f3b9f15c" MODIFIED="1593745252666" TEXT="JVM怎么保证线程安全"><node CREATED="1593745252666" ID="ID_263efc44b467" MODIFIED="1593745252666" TEXT="JVM以同步的形式完成类加载的整个过程"></node></node><node CREATED="1593745252666" ID="ID_d6312f39f2b4" MODIFIED="1593745252666" TEXT="保证实例的唯一性"><node CREATED="1593745252666" ID="ID_e842d63642d5" MODIFIED="1593745252666" TEXT="初始化过程只会执行一次"></node></node></node></node><node CREATED="1593745252666" ID="ID_efa26a7405cb" MODIFIED="1593745252666" TEXT="缺点"><node CREATED="1593745252666" ID="ID_771dca432290" MODIFIED="1593745252666" TEXT="类加载的时候，静态变量被创建并分配内存空间。因此在特定条件下会耗费内存"></node></node><node CREATED="1593745252666" ID="ID_173684df052c" MODIFIED="1593745252666" TEXT="实现"><richcontent TYPE="NOTE"><html><head></head><body><p>```
public class Singleton {

    // 定义一个私有的构造方法
    private Singleton(){
    }

    // 将自身的实例对象设置为一个属性，并加上static和final修饰符
    private static final Singleton instance = new Singleton();

    // 静态方法返回该类的实例
    public static Singleton getInstance(){
        return instance;
    }
}
```

</p></body></html></richcontent></node></node><node CREATED="1593745252666" ID="ID_5e208213b1ff" MODIFIED="1593745252666" TEXT="懒汉式"><node CREATED="1593745252666" ID="ID_9f32de88a96f" MODIFIED="1593745252666" TEXT="优点"><node CREATED="1593745252666" ID="ID_10153465bfa9" MODIFIED="1593745252666" TEXT="实现简单，类加载的时候不会创建，当getInstance方法第一次被调用时，才初始化并分配内存"></node></node><node CREATED="1593745252666" ID="ID_53c3a2aacfe3" MODIFIED="1593745252666" TEXT="缺点"><node CREATED="1593745252666" ID="ID_0b559371f97c" MODIFIED="1593745252666" TEXT="再并发环境下很可能出现多个实例"></node></node><node CREATED="1593745252666" ID="ID_10a98105bc59" MODIFIED="1593745252666" TEXT="实现"><richcontent TYPE="NOTE"><html><head></head><body><p>```
public class Singleton {

    // 定义私有构造方法
    private Singleton(){
    }

    // 定义一个Singleton类型的变量,不初始化
    private static Singleton instance;

    // 定义一个静态的方法(调用时再初始化)
    public static Singleton getInstance(){
        if(instance == null){
            instance = new Singleton();
        }
        return instance;
    }
}
```</p></body></html></richcontent></node></node><node CREATED="1593745252666" ID="ID_c6826991326f" MODIFIED="1593745252666" TEXT="饱汉式"><node CREATED="1593745252666" ID="ID_e9be9af8f131" MODIFIED="1593745252666" TEXT="优点"><node CREATED="1593745252666" ID="ID_2e3c10c386bc" MODIFIED="1593745252666" TEXT="使用synchronized关键字避免多线程访问"></node></node><node CREATED="1593745252666" ID="ID_621529500843" MODIFIED="1593745252666" TEXT="缺点"><node CREATED="1593745252666" ID="ID_2d310086593f" MODIFIED="1593745252666" TEXT="同步方法频繁调用时，效率低"></node></node><node CREATED="1593745252666" ID="ID_4bc9b4d62967" MODIFIED="1593745252666" TEXT="实现"><richcontent TYPE="NOTE"><html><head></head><body><p>```
public class Singleton {

    // 定义私有构造方法
    private Singleton() {
    }

    // 定义一个Singleton类型的变量,不初始化
    private static Singleton instance;
    
    // 定义一个静态的方法(调用时再初始化,使用synchronized避免多线程访问)
    public static synchronized Singleton getInstance(){
        if(instance == null){
            instance = new Singleton();
        }
        return instance;
    }
}
```</p></body></html></richcontent></node></node><node CREATED="1593745252666" ID="ID_3bd003f9fdce" MODIFIED="1593745252666" TEXT="双检锁"><node CREATED="1593745252666" ID="ID_56954a79b7c8" MODIFIED="1593745252666" TEXT="优点"><node CREATED="1593745252666" ID="ID_f9ae0c981390" MODIFIED="1593745252666" TEXT="避免了整个方法被锁，只需对需要锁的代码部分加锁，提高执行效率"></node></node><node CREATED="1593745252666" ID="ID_904715787508" MODIFIED="1593745252666" TEXT="实现"><richcontent TYPE="NOTE"><html><head></head><body><p>```
public class Singleton {

    // 定义私有构造方法
    private Singleton(){
    }

    // 定义一个Singleton类型的变量,不初始化
    // 用volatile修饰,防止指令重排
    private volatile static Singleton singleton = null;

    // 双重检查
    public static Singleton getInstance(){
        if(singleton == null){
            synchronized (Singleton.class){
                if(singleton == null){
                    singleton = new Singleton();
                }
            }
        }
        return singleton;
    }
}
```</p></body></html></richcontent></node></node><node CREATED="1593745252666" ID="ID_5c13c634903f" MODIFIED="1593745252666" TEXT="静态内部类"><node CREATED="1593745252666" ID="ID_da260dd01b7b" MODIFIED="1593745252666" TEXT="优点"><node CREATED="1593745252666" ID="ID_1ca6142ac3dc" MODIFIED="1593745252666" TEXT="不会在单例加载时就加载，而是在调用getInstance()方法时才进行加载，且是线程安全的"></node></node><node CREATED="1593745252666" ID="ID_1b5661dd7380" MODIFIED="1593745252666" TEXT="缺点"><node CREATED="1593745252666" ID="ID_a03bbdea8f9a" MODIFIED="1593745252666" TEXT="遇到序列化对象时，默认的方式运行得到的结果就是多例的"></node></node><node CREATED="1593745252666" ID="ID_fbd4f19140cc" MODIFIED="1593745252666" TEXT="实现"><richcontent TYPE="NOTE"><html><head></head><body><p>```
public class Singleton {

    // 定义私有构造方法
    private Singleton(){
    }

    // 静态内部类获取实例对象
    private static class SingletonHolder{
        private static Singleton instance = new Singleton();
    }

    // 静态方法，返回实例对象
    public static Singleton getInstance(){
        return SingletonHolder.instance;
    }
}
```</p></body></html></richcontent></node></node><node CREATED="1593745252666" ID="ID_fcea11bb64fa" MODIFIED="1593745252666" TEXT="内部枚举类"><node CREATED="1593745252666" ID="ID_29f736a40f81" MODIFIED="1593745252666" TEXT="优点"><node CREATED="1593745252666" ID="ID_bc7811c8c54c" MODIFIED="1593745252666" TEXT="自由序列化"></node><node CREATED="1593745252666" ID="ID_4f27a4ecad8a" MODIFIED="1593745252666" TEXT="保证只有一个实例"></node><node CREATED="1593745252666" ID="ID_a20c41639c66" MODIFIED="1593745252666" TEXT="线程安全"></node></node><node CREATED="1593745252666" ID="ID_07ff9f62bac8" MODIFIED="1593745252666" TEXT="实现"><richcontent TYPE="NOTE"><html><head></head><body><p>```
public class Singleton {

    private enum EnumSingleton{
        Singleton;
        private Singleton singleton;

        // 枚举类的构造方法在类加载的时候被实例化
        private EnumSingleton(){
            singleton = new Singleton();
        }
        
        public Singleton getInstance(){
            return singleton;
        }
    }
    
    // 静态方法调用内部枚举类的实例对象
    public static Singleton getInstance(){
        return EnumSingleton.Singleton.getInstance();
    }
}
```</p></body></html></richcontent></node></node></node></node><node CREATED="1593745252666" ID="ID_17d08cb615b8" MODIFIED="1593745252666" TEXT="一致性哈希"><node CREATED="1593745252666" ID="ID_b273e467b9cb" MODIFIED="1593745252666" TEXT="使用hash(服务器IP) % 2^32,使用hash(对象)%2^32。对象缓存到从对象的位置，顺时针方向遇到的第一个服务器"></node><node CREATED="1593745252666" ID="ID_66e6a280cc50" MODIFIED="1593745252666" TEXT="虚拟节点解决hash环的偏斜"></node></node><node CREATED="1593745252666" ID="ID_ff50ff7c1ee0" MODIFIED="1593745252666" TEXT="反射"><node CREATED="1593745252666" ID="ID_f4450bfa04d5" MODIFIED="1593745252666" TEXT="在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法。对于任意一个对象，都能够调用它的任意一个方法和属性"></node><node CREATED="1593745252666" ID="ID_df048b72e813" MODIFIED="1593745252666" TEXT="获取Class对象的三种方式"><node CREATED="1593745252666" ID="ID_46099a9ef12e" MODIFIED="1593745252666" TEXT="通过对象的getClass()方法进行获取。这种方式需要具体的类和该类的对象，以及调用getClass方法"></node><node CREATED="1593745252666" ID="ID_25b540a39c52" MODIFIED="1593745252666" TEXT="任何数据类型都具备一个静态的属性class，通过它可直接获取到该类型对应的Class对象。这种方式要使用具体的类，然后调用类中的静态属性class完成，无需调用方法，性能更好"></node><node CREATED="1593745252666" ID="ID_9bf51963521e" MODIFIED="1593745252666" TEXT="通过Class.forName(）方法获取。这种方式仅需使用类名"></node></node></node><node CREATED="1593745252666" ID="ID_c6c0372a15d7" MODIFIED="1593745252666" TEXT="动态代理"><node CREATED="1593745252666" ID="ID_31c59d8a750b" MODIFIED="1593745252666" TEXT="代理是一种设计模式，提供了对目标对象另外的访问方式；即通过代理访问目标对象"></node><node CREATED="1593745252666" ID="ID_87e65828778c" MODIFIED="1593745252666" TEXT="代理类与委托类有同样的接口，代理类主要负责为委托类预处理消息、过滤消息、把消息转发给委托类，以及事后处理消息，在目标对象实现的基础上，增强额外的功能操作。代理类的对象本身并不真正实现服务，而是通过调用委托类的对象的相关方法，来提供特定的服务"></node></node><node CREATED="1593745252666" ID="ID_d734f41a99db" MODIFIED="1593745252666" TEXT="深拷贝和浅拷贝的区别"><node CREATED="1593745252666" ID="ID_eae104a04533" MODIFIED="1593745252666" TEXT="浅拷贝"><node CREATED="1593745252666" ID="ID_56fbe5efb0ec" MODIFIED="1593745252666" TEXT="①对于数据类型是基本数据类型的成员变量，浅拷贝会直接进行值传递，也就是将该属性值复制一份给新的对象。因为是两份不同的数据，所以对其中一个对象的该成员变量值进行修改，不会影响另一个对象拷贝得到的数据。②对于数据类型是引用数据类型的成员变量，比如说成员变量是某个数组、某个类的对象等，那么浅拷贝会进行引用传递，也就是只是将该成员变量的引用值（内存地址）复制一份给新的对象。因为实际上两个对象的该成员变量都指向同一个实例。在这种情况下，在一个对象中修改该成员变量会影响到另一个对象的该成员变量值。"></node></node><node CREATED="1593745252666" ID="ID_360eed4a0a7a" MODIFIED="1593745252666" TEXT="深拷贝"><node CREATED="1593745252666" ID="ID_bb854968150c" MODIFIED="1593745252666" TEXT="深拷贝对引用数据类型的成员变量的对象图中所有的对象都开辟了内存空间"></node></node></node><node CREATED="1593745252666" ID="ID_191309908050" MODIFIED="1593745252666" TEXT="Exception"><node CREATED="1593745252666" ID="ID_a45de3606c0a" MODIFIED="1593745252666" TEXT="Error和Exception的区别"><node CREATED="1593745252666" ID="ID_7a72498cef22" MODIFIED="1593745252666" TEXT="Error是系统的错误，程序员是不能改变和处理的，是在程序编译时出现的错误，只能通过修改程序才能修正"></node><node CREATED="1593745252666" ID="ID_084868c16ffd" MODIFIED="1593745252666" TEXT="Exception"><node CREATED="1593745252666" ID="ID_470ea7ddcc60" MODIFIED="1593745252666" TEXT="Exception表示程序可以处理的异常，可以捕获且可能恢复"></node><node CREATED="1593745252666" ID="ID_b0a699036b23" MODIFIED="1593745252666" TEXT="CheckedException"><node CREATED="1593745252666" ID="ID_8cea0b85bb82" MODIFIED="1593745252666" TEXT="需要用try-catch显示的捕捉，对于可恢复的异常使用"></node></node><node CREATED="1593745252666" ID="ID_a19026619b71" MODIFIED="1593745252666" TEXT="RuntimeException"><node CREATED="1593745252666" ID="ID_1a5bef1e625b" MODIFIED="1593745252666" TEXT="不需要捕获，对于程序错误"></node></node></node></node></node><node CREATED="1593745252666" ID="ID_7a102ee63645" MODIFIED="1593745252666" TEXT="序列化"><node CREATED="1593745252666" ID="ID_d4dd4fecf321" MODIFIED="1593745252666" TEXT="序列化"><node CREATED="1593745252666" ID="ID_edb29f45ea75" MODIFIED="1593745252666" TEXT="把对象转换为字节序列的过程称为对象的序列化"></node></node><node CREATED="1593745252666" ID="ID_ed590e665be0" MODIFIED="1593745252666" TEXT="反序列化"><node CREATED="1593745252666" ID="ID_339dc3f6d62d" MODIFIED="1593745252666" TEXT="把字节序列恢复为对象的过程称为对象的反序列化"></node></node><node CREATED="1593745252666" ID="ID_cc7ca6631b3b" MODIFIED="1593745252666" TEXT="序列化的用途"><node CREATED="1593745252666" ID="ID_5bf3db8af3ab" MODIFIED="1593745252666" TEXT="把内存中的对象状态保存到一个文件中或者数据库中"></node><node CREATED="1593745252666" ID="ID_ec80d59d7a3b" MODIFIED="1593745252666" TEXT="用socket在网络上传送对象的时候"></node></node></node><node CREATED="1593745252666" ID="ID_d5051b1acbee" MODIFIED="1593745252666" TEXT="排序算法"><node CREATED="1593745252666" ID="ID_07daa9f82ebf" MODIFIED="1593745252666" TEXT="选择排序"><node CREATED="1593745252666" ID="ID_4112a4a220d1" MODIFIED="1593745252667" TEXT="n平方"></node><node CREATED="1593745252667" ID="ID_0edf460f6dfe" MODIFIED="1593745252667" TEXT="n平方"></node><node CREATED="1593745252667" ID="ID_f551943f4fe8" MODIFIED="1593745252667" TEXT="每一趟从待排序的记录中选出最小的元素，顺序放在已排好序的序列最后，直到全部记录排序完毕。"></node></node><node CREATED="1593745252667" ID="ID_45cf9b65e66f" MODIFIED="1593745252667" TEXT="插入排序"><node CREATED="1593745252667" ID="ID_7133c89da4eb" MODIFIED="1593745252667" TEXT="n"></node><node CREATED="1593745252667" ID="ID_53265f3afccb" MODIFIED="1593745252667" TEXT="n平方"></node><node CREATED="1593745252667" ID="ID_a7bf69618f2c" MODIFIED="1593745252667" TEXT="从整个待排序列中选出一个元素插入到已经有序的子序列中去，得到一个有序的、元素加一的子序列，直到整个序列的待插入元素为0，则整个序列全部有序"></node></node><node CREATED="1593745252667" ID="ID_8ea9b8801609" MODIFIED="1593745252667" TEXT="冒泡排序"><node CREATED="1593745252667" ID="ID_120816c6dd73" MODIFIED="1593745252667" TEXT="n"></node><node CREATED="1593745252667" ID="ID_29da88256315" MODIFIED="1593745252667" TEXT="n平方"></node><node CREATED="1593745252667" ID="ID_95326613df00" MODIFIED="1593745252667" TEXT="比较两个相邻的元素，将值大的元素交换至右端"></node></node><node CREATED="1593745252667" ID="ID_acfe9a61c1f2" MODIFIED="1593745252667" TEXT="希尔排序"><node CREATED="1593745252667" ID="ID_db1c1fe4f396" MODIFIED="1593745252667" TEXT="n"></node><node CREATED="1593745252667" ID="ID_b92c0a6ad2a9" MODIFIED="1593745252667" TEXT="n2"></node><node CREATED="1593745252667" ID="ID_5cbd362bd608" MODIFIED="1593745252667" TEXT="希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。"></node></node><node CREATED="1593745252667" ID="ID_061b987f8e83" MODIFIED="1593745252667" TEXT="快速排序"><node CREATED="1593745252667" ID="ID_0f0279607848" MODIFIED="1593745252667" TEXT="nlgn"></node><node CREATED="1593745252667" ID="ID_692be8662b9d" MODIFIED="1593745252667" TEXT="n2"></node></node><node CREATED="1593745252667" ID="ID_abe201a6e068" MODIFIED="1593745252667" TEXT="堆排序"><node CREATED="1593745252667" ID="ID_2cde923dba7c" MODIFIED="1593745252667" TEXT="nlgn"></node><node CREATED="1593745252667" ID="ID_99b7cb3e69ec" MODIFIED="1593745252667" TEXT="nlgn"></node></node><node CREATED="1593745252667" ID="ID_52330b6ffb1c" MODIFIED="1593745252667" TEXT="&amp;nbsp;归并排序"><node CREATED="1593745252667" ID="ID_2569216b5801" MODIFIED="1593745252667" TEXT="nlgn"></node><node CREATED="1593745252667" ID="ID_c050cf341e90" MODIFIED="1593745252667" TEXT="nlgn"></node></node></node><node CREATED="1593745252667" ID="ID_9bdbc6d84511" MODIFIED="1593745252667" TEXT="CPU缓存一致性协议"><node CREATED="1593745252667" ID="ID_e2fd707a21b7" MODIFIED="1593745252667" LINK="https://www.cnblogs.com/yanlong300/p/8986041.html" TEXT="https://www.cnblogs.com/yanlong300/p/8986041.html"></node></node><node CREATED="1593745252667" ID="ID_1caa6f7ca383" MODIFIED="1593745252667" TEXT="同步，异步，阻塞，非阻塞概念"><node CREATED="1593745252667" ID="ID_41da1ae6eb51" MODIFIED="1593745252667" LINK="https://blog.csdn.net/lengxiao1993/article/details/78154467" TEXT="https://blog.csdn.net/lengxiao1993/article/details/78154467"></node></node><node CREATED="1593745252667" ID="ID_b1a291602ceb" MODIFIED="1593745252667" TEXT="RPC"></node><node CREATED="1593745252667" ID="ID_d55e34e8d88d" MODIFIED="1593745252667" TEXT="僵尸进程与孤儿进程"><node CREATED="1593745252667" ID="ID_f306b366835b" MODIFIED="1593745252667" LINK="https://blog.csdn.net/Eunice_fan1207/article/details/81387417" TEXT="https://blog.csdn.net/Eunice_fan1207/article/details/81387417"></node></node><node CREATED="1593745252667" ID="ID_eada61eb06e0" MODIFIED="1593745252667" TEXT="分布式锁"><node CREATED="1593745252667" ID="ID_44ad8d1d0272" MODIFIED="1593745252667" TEXT="redis"><node CREATED="1593745252667" ID="ID_41d75674deb0" MODIFIED="1593745252667" TEXT="通过setnx拿到key，然后通过expire对该key设置过期时间，将这两个操作通过加锁整合成原子性操作"></node></node><node CREATED="1593745252667" ID="ID_e393ef38a18e" MODIFIED="1593745252667" TEXT="zookeeper"><node CREATED="1593745252667" ID="ID_83f5dbc026b2" MODIFIED="1593745252667" TEXT="多线程创建同一个临时节点，由于节点的唯一性，所以只会一个线程创建成功，其他线程watch这个节点。"></node><node CREATED="1593745252667" ID="ID_a7df32184c48" MODIFIED="1593745252667" TEXT="羊群问题"><node CREATED="1593745252667" ID="ID_e20f0091e769" MODIFIED="1593745252667" TEXT="当获得锁的线程释放锁后，所有等待的线程一起去抢这把锁，zk压力大。"></node><node CREATED="1593745252667" ID="ID_38af1894ff30" MODIFIED="1593745252667" TEXT="每个线程都去创建一个顺序临时节点，相互监听，将非公平锁化为公平锁"></node></node></node><node CREATED="1593745252667" ID="ID_35a5774baa12" MODIFIED="1593745252667" TEXT="zookeeper相对于redis有什么优势"><node CREATED="1593745252667" ID="ID_3b00117257ff" MODIFIED="1593745252667" TEXT="redis当主拿到锁后，如果没有及时同步就宕机，可能导致锁失效"></node><node CREATED="1593745252667" ID="ID_4f4dd1c5fa1d" MODIFIED="1593745252667" TEXT="zk通过zab协议的限制，从而保证了只有超过半数实例拿到数据才算写成功，不会出现这个问题"></node></node></node><node CREATED="1593745252667" ID="ID_98545a9a9d96" MODIFIED="1593745252667" TEXT="静态链接和动态链接"><node CREATED="1593745252667" ID="ID_a712e2e12f1a" MODIFIED="1593745252667" TEXT="静态链接"><node CREATED="1593745252667" ID="ID_20b377ec4e37" MODIFIED="1593745252667" TEXT="当一个字节码文件被装载进JVM内部时，如果被调用的目标方法在编译期可知，且运行期保持不变时。这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接"></node></node><node CREATED="1593745252667" ID="ID_0289e1fb890e" MODIFIED="1593745252667" TEXT="动态链接"><node CREATED="1593745252667" ID="ID_4a7bf76beb7d" MODIFIED="1593745252667" TEXT="如果被调用的方法在编译期无法被确定下来，也就是说，只能够在程序运行期将调用方法的符号引用转换为直接引用，由于这种引用转换过程具备动态性，因此也被称之为动态链接"></node></node></node></node><node CREATED="1593745252667" ID="ID_9497607461a4" POSITION="right" MODIFIED="1593745252667" TEXT="JVM"><node CREATED="1593745252667" ID="ID_871128809728" MODIFIED="1593745252667" TEXT="运行时数据区域"><node CREATED="1593745252667" ID="ID_78cb8c3eefff" MODIFIED="1593745252667" TEXT="线程私有"><node CREATED="1593745252667" ID="ID_7ec10a09ff18" MODIFIED="1593745252667" TEXT="程序计数器"><node CREATED="1593745252667" ID="ID_1205e7a9e7e0" MODIFIED="1593745252667" TEXT="字节码解释器通过改变程序计数器来一次读取指令，从而实现代码的流程控制"></node><node CREATED="1593745252667" ID="ID_55c4a138be4b" MODIFIED="1593745252667" TEXT="在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了"></node></node><node CREATED="1593745252667" ID="ID_e39f6481d142" MODIFIED="1593745252667" TEXT="虚拟机栈"><node CREATED="1593745252667" ID="ID_aff148ad0232" MODIFIED="1593745252667" TEXT="局部变量表"><node CREATED="1593745252667" ID="ID_429ff74dcac0" MODIFIED="1593745252667" TEXT="各种基本数据类型"></node><node CREATED="1593745252667" ID="ID_84356f6e81a7" MODIFIED="1593745252667" TEXT="对象引用"></node></node><node CREATED="1593745252667" ID="ID_1cde276b2da7" MODIFIED="1593745252667" TEXT="操作数栈"><node CREATED="1593745252667" ID="ID_a2d37a9022fc" MODIFIED="1593745252667" TEXT="操作数的临时存放内存"></node></node><node CREATED="1593745252667" ID="ID_25622b1ddc0c" MODIFIED="1593745252667" TEXT="动态链接"><node CREATED="1593745252667" ID="ID_67559bbab7b3" MODIFIED="1593745252667" TEXT="动态链接存储。在main方法中调用某个类的方法，该类的实例对象存在堆中，对象头记录着对应类元信息所在的方法区的指针。在调用这个方法的时候，会将该指针所存储的对应方法的字节码位置存入动态链接"></node></node><node CREATED="1593745252667" ID="ID_9124fc466401" MODIFIED="1593745252667" TEXT="方法出口"><node CREATED="1593745252667" ID="ID_7ffc07bd8bb1" MODIFIED="1593745252667" TEXT="下一步main方法要执行的位置&amp;lt;br&amp;gt;"></node></node><node CREATED="1593745252667" ID="ID_00b34d810395" MODIFIED="1593745252667" TEXT="栈里每个方法都有自己的栈帧，用于存自己的局部变量表"></node></node><node CREATED="1593745252667" ID="ID_b718fbfec130" MODIFIED="1593745252667" TEXT="本地方法栈"><node CREATED="1593745252667" ID="ID_d66e701aa3cb" MODIFIED="1593745252667" TEXT="为虚拟机使用到的Native方法服务"></node></node></node><node CREATED="1593745252667" ID="ID_d7e1fa6c10d2" MODIFIED="1593745252667" TEXT="线程共享"><node CREATED="1593745252667" ID="ID_5b62aa967bf3" MODIFIED="1593745252667" TEXT="堆"><node CREATED="1593745252667" ID="ID_2fbbe4d36a8a" MODIFIED="1593745252667" TEXT="存放对象实例"><node CREATED="1593745252667" ID="ID_ea8eee5e06bd" MODIFIED="1593745252667" TEXT="年轻代"><node CREATED="1593745252667" ID="ID_c0597f1ba115" MODIFIED="1593745252667" TEXT="伊甸园区"><node CREATED="1593745252667" ID="ID_3eda30da2409" MODIFIED="1593745252667" TEXT="minor GC(将剩余存活对象移动到survivor区)"></node></node><node CREATED="1593745252667" ID="ID_81dc47209e15" MODIFIED="1593745252667" TEXT="survivor区&amp;lt;br&amp;gt;"><node CREATED="1593745252667" ID="ID_de2e3ac687e9" MODIFIED="1593745252667" TEXT="From区"><node CREATED="1593745252667" ID="ID_df01c916dbd7" MODIFIED="1593745252667" TEXT="minor GC(将剩余存活对象移动到To区，两者来回挪动，直到java分代年龄到15，移动到老年代)&amp;lt;br&amp;gt;"></node></node><node CREATED="1593745252667" ID="ID_b420e4c2134e" MODIFIED="1593745252667" TEXT="To区"></node></node></node><node CREATED="1593745252667" ID="ID_9c9d9b4b9063" MODIFIED="1593745252667" TEXT="老年代"></node></node></node><node CREATED="1593745252667" ID="ID_04ee6cda2e7d" MODIFIED="1593745252667" TEXT="方法区"><node CREATED="1593745252667" ID="ID_2de73e169897" MODIFIED="1593745252667" TEXT="存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据"></node></node><node CREATED="1593745252667" ID="ID_7db857d9cb64" MODIFIED="1593745252667" TEXT="直接内存"><node CREATED="1593745252667" ID="ID_69dec9fa363b" MODIFIED="1593745252667" TEXT="避免Java堆和Native堆之间来回复制数据"></node></node></node></node><node CREATED="1593745252667" ID="ID_ce39de4760cd" MODIFIED="1593745252667" TEXT="对象创建过程"><node CREATED="1593745252667" ID="ID_ab33f7a751bb" MODIFIED="1593745252667" TEXT="类加载检查"><node CREATED="1593745252667" ID="ID_452c93f926f7" MODIFIED="1593745252667" TEXT="虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程"></node></node><node CREATED="1593745252667" ID="ID_ace680494766" MODIFIED="1593745252667" TEXT="分配内存"><node CREATED="1593745252667" ID="ID_7bcbae48a6ab" MODIFIED="1593745252667" TEXT="在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来"></node><node CREATED="1593745252667" ID="ID_dd6e2bbdfdea" MODIFIED="1593745252667" TEXT="分配方式"><node CREATED="1593745252667" ID="ID_2a954b7e244d" MODIFIED="1593745252667" TEXT="指针碰撞"></node><node CREATED="1593745252668" ID="ID_28ce6390c271" MODIFIED="1593745252668" TEXT="空闲列表"></node></node></node><node CREATED="1593745252668" ID="ID_c23bd0b82e2f" MODIFIED="1593745252668" TEXT="初始化零值"><node CREATED="1593745252668" ID="ID_e1020a289455" MODIFIED="1593745252668" TEXT=" 内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值"></node></node><node CREATED="1593745252668" ID="ID_548c941c2bce" MODIFIED="1593745252668" TEXT="设置对象头"><node CREATED="1593745252668" ID="ID_efa10b82e4a9" MODIFIED="1593745252668" TEXT="初始化零值完成之后，虚拟机要对对象进行必要的设置，例如这个对象是那个类的实例、如何才能找到类的元数据信息、对象的哈希吗、对象的 GC 分代年龄等信息。 这些信息存放在对象头中。 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式"></node></node><node CREATED="1593745252668" ID="ID_990cd977a75d" MODIFIED="1593745252668" TEXT="执行init方法"><node CREATED="1593745252668" ID="ID_c6cab64baa08" MODIFIED="1593745252668" TEXT="在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，&amp;lt;init&amp;gt; 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 &amp;lt;init&amp;gt; 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来"></node></node></node><node CREATED="1593745252668" ID="ID_951bafd7c589" MODIFIED="1593745252668" TEXT="类加载过程"><node CREATED="1593745252668" ID="ID_2fb99e18c86b" MODIFIED="1593745252668" TEXT="加载。在内存中生成一个代表这个类的java.lang.class对象，作为方法区这个类的各种数据入口&amp;lt;br&amp;gt;"></node><node CREATED="1593745252668" ID="ID_643b399a05a3" MODIFIED="1593745252668" TEXT="验证。确保class文件的字节流中包含的信息是否符合当前虚拟机的要求，并且不会危害虚拟机自身的安全"></node><node CREATED="1593745252668" ID="ID_abddd2c41908" MODIFIED="1593745252668" TEXT="准备。为变量分配内存并设置变量的初始值阶段，类变量分配在方法区，实例变量随着对象一起分配到Java堆"></node><node CREATED="1593745252668" ID="ID_e01664069f83" MODIFIED="1593745252668" TEXT="解析。虚拟机将常量池中的符号引用替换为直接引用的过程，即将class文件中字面量形式的符号引用替换为直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄"></node><node CREATED="1593745252668" ID="ID_2eb6cbfae1bc" MODIFIED="1593745252668" TEXT="初始化。执行类构造器方法(&amp;lt;clinit&amp;gt;)的过程，此方法是javac编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而来"></node></node><node CREATED="1593745252668" ID="ID_ef0a22eb3bdb" MODIFIED="1593745252668" TEXT="内存溢出与内存泄漏"><node CREATED="1593745252668" ID="ID_fcfa23139b0c" MODIFIED="1593745252668" TEXT="内存溢出"><node CREATED="1593745252668" ID="ID_e25df6ec85a7" MODIFIED="1593745252668" TEXT="程序在申请内存时，没有足够的内存空间供其使用"></node></node><node CREATED="1593745252668" ID="ID_66164a0023c6" MODIFIED="1593745252668" TEXT="内存泄漏"><node CREATED="1593745252668" ID="ID_16931b107678" MODIFIED="1593745252668" TEXT="程序在申请内存后，无法释放已申请的内存空间，一次内存泄漏危害可以忽略，但内存泄漏堆积后果很严重，无论多少内存，迟早会被占光"></node><node CREATED="1593745252668" ID="ID_e61e1a7ecd75" MODIFIED="1593745252668" TEXT="分类"><node CREATED="1593745252668" ID="ID_4f3e1f9e704b" MODIFIED="1593745252668" TEXT="常发性内存泄漏"><node CREATED="1593745252668" ID="ID_08779fea6e66" MODIFIED="1593745252668" TEXT="发生内存泄漏的代码会被多次执行，每次执行都会导致一块内存泄漏"></node></node><node CREATED="1593745252668" ID="ID_570a7af7aa4e" MODIFIED="1593745252668" TEXT="偶发性内存泄漏"><node CREATED="1593745252668" ID="ID_99202209fd3a" MODIFIED="1593745252668" TEXT="发生内存泄漏的代码只有在某些特定环境或操作过程下才会发生"></node></node><node CREATED="1593745252668" ID="ID_6d3612075b0e" MODIFIED="1593745252668" TEXT="一次性内存泄漏"><node CREATED="1593745252668" ID="ID_8e837ce9fc5b" MODIFIED="1593745252668" TEXT="发生内存泄漏的代码会被执行一次，或者由于算法上的缺陷，导致总会有一块仅且一块内存发生泄漏。例如：类的构造函数中分配内存，在析构函数中没有释放该内存"></node></node><node CREATED="1593745252668" ID="ID_fa0bb544bcb5" MODIFIED="1593745252668" TEXT="隐式内存泄漏"><node CREATED="1593745252668" ID="ID_a3580035555b" MODIFIED="1593745252668" TEXT="程序在运行过程中不停的分配内存，但是直到结束的时候才释放内存。对于一个服务器程序，需要运行很久，不及时释放内存可能导致最终耗尽系统的所有内存"></node></node></node><node CREATED="1593745252668" ID="ID_6d203f5a89af" MODIFIED="1593745252668" TEXT="内存泄漏原因"><node CREATED="1593745252668" ID="ID_7be3c3a4f4ba" MODIFIED="1593745252668" TEXT="无用对象持续占有内存或无用对象的内存得不到及时释放，从而造成内存空间的浪费"></node><node CREATED="1593745252668" ID="ID_14246e8146f4" MODIFIED="1593745252668" TEXT="长生命周期的对象持有短生命周期的对象的引用就很可能发生内存泄漏"></node></node><node CREATED="1593745252668" ID="ID_4ca367dbbd90" MODIFIED="1593745252668" TEXT="常见的内存泄漏"><node CREATED="1593745252668" ID="ID_f1258e19ef7f" MODIFIED="1593745252668" TEXT="单例造成内存泄漏"></node></node></node></node><node CREATED="1593745252668" ID="ID_00c57b71a593" MODIFIED="1593745252668" TEXT="GC"><node CREATED="1593745252668" ID="ID_17bbf9f8a93a" MODIFIED="1593745252668" TEXT="GC功能"><node CREATED="1593745252668" ID="ID_ec6d56e0c541" MODIFIED="1593745252668" TEXT="分配内存，为每个新建的对象分配空间"></node><node CREATED="1593745252668" ID="ID_56a54475247c" MODIFIED="1593745252668" TEXT="确保还在使用的对象的内存一直都在，不能把有用的空间当垃圾回收"></node><node CREATED="1593745252668" ID="ID_99846c16becc" MODIFIED="1593745252668" TEXT="释放不再使用的对象所占用的内存"></node></node><node CREATED="1593745252668" ID="ID_89a73599b81f" MODIFIED="1593745252668" TEXT="GC Roots"><node CREATED="1593745252668" ID="ID_ee120f8ab19d" MODIFIED="1593745252668" TEXT="虚拟机栈中局部变量表中引用的对象"></node><node CREATED="1593745252668" ID="ID_b57de01672cf" MODIFIED="1593745252668" TEXT="本地方法栈中JNI中引用的对象"></node><node CREATED="1593745252668" ID="ID_e96b9f13db77" MODIFIED="1593745252668" TEXT="方法区中类静态属性引用的对象"></node><node CREATED="1593745252668" ID="ID_1c5089c11b24" MODIFIED="1593745252668" TEXT="方法区中的常量引用的对象"></node></node><node CREATED="1593745252668" ID="ID_aac3680cfdec" MODIFIED="1593745252668" TEXT="内存分类"><node CREATED="1593745252668" ID="ID_49f3eafcf106" MODIFIED="1593745252668" TEXT="年轻代"><node CREATED="1593745252668" ID="ID_c507d7d888bc" MODIFIED="1593745252668" TEXT="大部分对象初始化都是在年轻代"></node></node><node CREATED="1593745252668" ID="ID_5c96eb66f0c3" MODIFIED="1593745252668" TEXT="老年代"><node CREATED="1593745252668" ID="ID_17fc8fcea4ef" MODIFIED="1593745252668" TEXT="老年代存放经过几次年轻代垃圾收集还活着的对象，还有部分大对象因为比较大，所以直接分配在老年代"></node></node><node CREATED="1593745252668" ID="ID_3c7b212f92d7" MODIFIED="1593745252668" TEXT="永久代"><node CREATED="1593745252668" ID="ID_d00a9d40664a" MODIFIED="1593745252668" TEXT="永久代通常也叫方法区，用于存储已加载类的元数据，以及存储运行时常量池"></node></node></node><node CREATED="1593745252668" ID="ID_d91bd5492bc0" MODIFIED="1593745252668" TEXT="垃圾回收类型"><node CREATED="1593745252668" ID="ID_1f70218ebf84" MODIFIED="1593745252668" TEXT="minor GC"><node CREATED="1593745252668" ID="ID_d8b62bc9cc35" MODIFIED="1593745252668" TEXT="当年轻代被填满后，会进行一次年轻代垃圾收集"></node></node><node CREATED="1593745252668" ID="ID_63d838667567" MODIFIED="1593745252668" TEXT="fulll GC"><node CREATED="1593745252668" ID="ID_584f0c8127b2" MODIFIED="1593745252668" TEXT="当老年代或永久代被填满后，会触发full GC，full GC会收集所有区域，先进行年轻代的收集，使用年轻代专用的垃圾回收算法，然后使用老年代的垃圾回收算法回收老年代和永久代，如果算法带有压缩，每个代分别独立的进行压缩"></node><node CREATED="1593745252668" ID="ID_fcf9d7579c25" MODIFIED="1593745252668" TEXT="Full GC本身不会先进行Minor GC，我们可以配置，让Full GC之前先进行一次Minor GC，因为老年代很多对象都会引用到新生代的对象，先进行一次Minor GC可以提高老年代GC的速度。比如老年代使用CMS时，设置CMSScavengeBeforeRemark优化，让CMS remark之前先进行一次Minor GC"></node></node></node><node CREATED="1593745252668" ID="ID_c0ab392fc9f5" MODIFIED="1593745252668" TEXT="分配内存"><node CREATED="1593745252668" ID="ID_58f781da94e1" MODIFIED="1593745252668" TEXT="如果垃圾收集完成后，存在大片连续的内存可用于分配新对象，此时使用指针碰撞分配对象空间"></node><node CREATED="1593745252668" ID="ID_6e9e364626cf" MODIFIED="1593745252668" TEXT="对于多线程应用，对象分配必须要保证线程安全性，如果使用全局锁，那么分配空间将成为瓶颈，降低程序性能。HotSpot使用TLABs，给每个线程一部分内存作为缓存区，每个线程缓存区进行指针碰撞，就不用获取全局锁"></node></node><node CREATED="1593745252668" ID="ID_4ab6cefeb28b" MODIFIED="1593745252668" TEXT="GC算法"><node CREATED="1593745252668" ID="ID_9582b826bbf7" MODIFIED="1593745252668" TEXT="引用计数"></node><node CREATED="1593745252668" ID="ID_e9cb98dbb9fd" MODIFIED="1593745252668" TEXT="复制"></node><node CREATED="1593745252668" ID="ID_71d031345688" MODIFIED="1593745252668" TEXT="标记清除"></node><node CREATED="1593745252668" ID="ID_8ec5d07c93f9" MODIFIED="1593745252668" TEXT="标记整理"></node></node><node CREATED="1593745252668" ID="ID_93170e752192" MODIFIED="1593745252668" TEXT="收集器"><node CREATED="1593745252668" ID="ID_ffb8c0df54af" MODIFIED="1593745252668" TEXT="串行"><node CREATED="1593745252668" ID="ID_bb3852ed8ecd" MODIFIED="1593745252668" TEXT="有一个线程进行垃圾回收，会暂停所有的用户线程"></node></node><node CREATED="1593745252668" ID="ID_501a85675c0f" MODIFIED="1593745252668" TEXT="并行"><node CREATED="1593745252668" ID="ID_c772feba02f4" MODIFIED="1593745252668" TEXT="多个线程进行垃圾回收，会暂停所有的用户线程"></node></node><node CREATED="1593745252668" ID="ID_d456a8630c6b" MODIFIED="1593745252668" TEXT="CMS"><node CREATED="1593745252668" ID="ID_c17508ebf35e" MODIFIED="1593745252668" TEXT="在年轻代中，CMS和并行收集器一样，即：并行、stop-the-world、复制"></node><node CREATED="1593745252668" ID="ID_edf4c466d623" MODIFIED="1593745252668" TEXT="在老年代中，大部分收集任务是和应用程序并发执行的"></node><node CREATED="1593745252668" ID="ID_9965c7a60327" MODIFIED="1593745252668" TEXT="CMS 收集过程首先是一段小停顿 stop-the-world，叫做 初始标记阶段（initial mark），用于确定 GC Roots。然后是 并发标记阶段（concurrent mark），标记 GC Roots 可达的所有存活对象，由于这个阶段应用程序同时也在运行，所以并发标记阶段结束后，并不能标记出所有的存活对象。为了解决这个问题，需要再次停顿应用程序，称为 再次标记阶段（remark），遍历在并发标记阶段应用程序修改的对象（标记出应用程序在这个期间的活对象），由于这次停顿比初始标记要长得多，所以会使用多线程并行执行来增加效率。再次标记阶段结束后，能保证所有存活对象都被标记完成，所以接下来的 并发清理阶段（concurrent sweep） 将就地回收垃圾对象所占空间"></node><node CREATED="1593745252668" ID="ID_b3cfbb00f4cc" MODIFIED="1593745252668" TEXT="CMS是唯一不进行压缩的收集器，在它释放了垃圾对象占用的空间后，不会移动存活对象到一边去，节省垃圾回收的时间"></node><node CREATED="1593745252668" ID="ID_7bee9d0affb2" MODIFIED="1593745252668" TEXT="缺点"><node CREATED="1593745252668" ID="ID_bddeed08bade" MODIFIED="1593745252668" TEXT="由于空闲空间不是连续的，所以也就不能使用简单的 指针碰撞（bump-the-pointer） 进行对象空间分配了。它需要维护一个 空闲列表，将所有的空闲区域连接起来，当分配空间时，需要寻找到一个可以容纳该对象的区域"></node><node CREATED="1593745252668" ID="ID_fe28239e2e76" MODIFIED="1593745252668" TEXT="CMS 收集器相比其他收集器需要使用更大的堆内存。因为在并发标记阶段，程序还需要执行，所以需要留足够的空间给应用程序"></node><node CREATED="1593745252668" ID="ID_b4026417bd38" MODIFIED="1593745252668" TEXT="虽然收集器能保证在标记阶段识别出所有的存活对象，但是由于应用程序并发运行，所以刚刚标记的存活对象很可能立马成为垃圾，而且这部分由于已经被标记为存活对象，所以只能到下次老年代收集才会被清理，这部分垃圾称为 浮动垃圾"></node><node CREATED="1593745252668" ID="ID_62ee95d8bac8" MODIFIED="1593745252668" TEXT="由于缺少压缩环节，堆将会出现碎片化问题。为了解决这个问题，CMS 收集器需要追踪统计最常用的对象大小，评估将来的分配需求，可能还需要分割或合并空闲区域"></node></node></node><node CREATED="1593745252668" ID="ID_dcca11014031" MODIFIED="1593745252668" TEXT="G1"><node CREATED="1593745252668" ID="ID_6fa57d114007" MODIFIED="1593745252668" TEXT="年轻代收集"><node CREATED="1593745252668" ID="ID_9d6f92b74121" MODIFIED="1593745252668" TEXT="G1收集器将堆内存分为大小固定的区块，整堆分为约2000块，每块大小是一致的逻辑上，也会分为Eden、Survivor、Old区，但是各个区的大小不是固定的，未分配区可以用于任何一代年轻代由几个不连续的区块组成，这样需要的时候可以很容易扩容、缩容Young GC是并行、stop-the-world的将活着的对象复制到Survivor区，或晋升到Old区为了下一次Young GC，需要计算Eden区和Survivor区的大小"></node></node><node CREATED="1593745252669" ID="ID_e309d31c7a8c" MODIFIED="1593745252669" TEXT="老年代收集"><node CREATED="1593745252669" ID="ID_3c6ed091d584" MODIFIED="1593745252669" TEXT="初始标记：stop-the-world，它伴随着一次普通的 Young GC 发生，然后对 Survivor 区（root region）进行标记，因为该区可能存在对老年代的引用。&amp;lt;br&amp;gt;扫描根引用区：扫描 Survivor 到老年代的引用，该阶段必须在下一次 Young GC 发生前结束。&amp;lt;br&amp;gt;并发标记：寻找整个堆的存活对象，该阶段可以被 Young GC 中断。&amp;lt;br&amp;gt;重新标记：stop-the-world，完成最后的存活对象标记。使用了比 CMS 收集器更加高效的 snapshot-at-the-beginning (SATB) 算法。&amp;lt;br&amp;gt;清理：清理阶段真正回收的内存很少"></node></node><node CREATED="1593745252669" ID="ID_6b0042eeb7a8" MODIFIED="1593745252669" TEXT="G1调优（避免Full GC）"><node CREATED="1593745252669" ID="ID_6d0d7b608e67" MODIFIED="1593745252669" TEXT="增加堆大小，调整老年代和年轻代的比例"></node><node CREATED="1593745252669" ID="ID_517fc1f001d7" MODIFIED="1593745252669" TEXT="怎加并发周期的线程数量，缩短并发周期"></node><node CREATED="1593745252669" ID="ID_3015a1cc4d57" MODIFIED="1593745252669" TEXT="设置堆占用比，让并发周期尽早开始"></node><node CREATED="1593745252669" ID="ID_d440a14a31ac" MODIFIED="1593745252669" TEXT="在混合垃圾回收周期中回收更多的老年代区块"></node></node></node><node CREATED="1593745252669" ID="ID_bbab352d76cb" MODIFIED="1593745252669" TEXT="G1对比CMS"><node CREATED="1593745252669" ID="ID_c2a99cf3ef4c" MODIFIED="1593745252669" TEXT="优点"><node CREATED="1593745252669" ID="ID_aec7944675ab" MODIFIED="1593745252669" TEXT="G1是一个有整理内存过程的垃圾收集器，不会产生过多内存碎片"></node><node CREATED="1593745252669" ID="ID_5dcd9c03032e" MODIFIED="1593745252669" TEXT="用户可以指定期望停顿时间"></node></node><node CREATED="1593745252669" ID="ID_0bf7b94d1f08" MODIFIED="1593745252669" TEXT="共同点"><node CREATED="1593745252669" ID="ID_19d4d6a306e7" MODIFIED="1593745252669" TEXT="都是并发收集器"></node></node></node></node></node><node CREATED="1593745252669" ID="ID_8a263adb1f1f" MODIFIED="1593745252669" TEXT="强引用，软引用，弱引用，虚引用"><node CREATED="1593745252669" ID="ID_50f8510baa96" MODIFIED="1593745252669" TEXT="强引用"><node CREATED="1593745252669" ID="ID_64f6dba31473" MODIFIED="1593745252669" TEXT="只要引用存在，垃圾回收器永远不会回收"></node></node><node CREATED="1593745252669" ID="ID_729baf0504c2" MODIFIED="1593745252669" TEXT="软引用"><node CREATED="1593745252669" ID="ID_b595ca8d7df5" MODIFIED="1593745252669" TEXT="非必须引用，内存溢出之前进行回收"></node></node><node CREATED="1593745252669" ID="ID_3ab505b093d3" MODIFIED="1593745252669" TEXT="弱引用"><node CREATED="1593745252669" ID="ID_393de45b559b" MODIFIED="1593745252669" TEXT="一定会被回收，被弱引用关联的对象只能存活到下一次垃圾回收之前"></node></node><node CREATED="1593745252669" ID="ID_90bbadda245b" MODIFIED="1593745252669" TEXT="虚引用"><node CREATED="1593745252669" ID="ID_1d4f6a7110cb" MODIFIED="1593745252669" TEXT="虚引用是每次垃圾回收的时候都会被回收"></node></node></node><node CREATED="1593745252669" ID="ID_f81a43d6a663" MODIFIED="1593745252669" TEXT="双亲委派模型"><node CREATED="1593745252669" ID="ID_5b6e63773c97" MODIFIED="1593745252669" TEXT="除了顶层的启动类加载器之外，其余的类加载器都应当有自己的父类加载器。类加载器之间的父子关系不会以继承的关系来实现，而是使用组合关系来复用父加载器的代码"></node><node CREATED="1593745252669" ID="ID_fb3ad04b3ed7" MODIFIED="1593745252669" TEXT="工作过程"><node CREATED="1593745252669" ID="ID_8ac349bd0cae" MODIFIED="1593745252669" TEXT="一个类加载器收到了类加载的请求，首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一层次的类加载器都是如此，只有当父加载器反馈自己无法完成这个加载请求时，子加载器才会尝试自己去加载"></node></node><node CREATED="1593745252669" ID="ID_a145742bcef7" MODIFIED="1593745252669" TEXT="优势"><node CREATED="1593745252669" ID="ID_64b20dcfbad6" MODIFIED="1593745252669" TEXT="避免类的重复加载"></node><node CREATED="1593745252669" ID="ID_875ea1aba320" MODIFIED="1593745252669" TEXT="保护程序安全，防止核心API被篡改"></node></node></node></node></node></map>